<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ludo</title>
    <style>
        :root {
            --board-size: clamp(320px, 90vmin, 650px);
            --cell-size: calc(var(--board-size) / 15);
            --pawn-size: calc(var(--cell-size) * 0.7);
            --hop-duration: 0.5s;

            --red-color: #d63031;
            --green-color: #00b894;
            --yellow-color: #fdd835;
            --blue-color: #0984e3;

            --red-home: #e17055;
            --green-home: #55efc4;
            --yellow-home: #ffeaa7;
            --blue-home: #74b9ff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2c3e50;
            background-image: radial-gradient(circle, #34495e, #2c3e50);
            color: #fff;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #game-container {
            display: flex;
            flex-direction: row;
            justify-content: center;
            gap: 30px;
            align-items: center;
            width: 100%;
        }

        #board {
            width: var(--board-size);
            height: var(--board-size);
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            border: 10px solid #634832;
            border-radius: 15px;
            background-color: #c89666;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 80 80"><rect width="80" height="80" fill="%23c89666"/><path d="M 0,10 C 20,0, 40,0, 60,10 C 80,20, 80,30, 80,40 C 70,60, 60,80, 40,80 C 20,80, 0,60, 0,40z" fill-opacity="0.1" fill="%235a3a22"/><path d="M 80,10 C 60,0, 40,0, 20,10 C 0,20, 0,30, 0,40 C 10,60, 20,80, 40,80 C 60,80, 80,60, 80,40z" fill-opacity="0.1" fill="%235a3a22"/></svg>');
            box-shadow: 0 15px 30px rgba(0,0,0,0.5), inset 0 0 10px rgba(0,0,0,0.3);
            position: relative;
            flex-shrink: 0;
        }
        
        #board::before {
            content: '';
            position: absolute;
            top: calc(var(--cell-size) * 6); left: calc(var(--cell-size) * 6);
            width: calc(var(--cell-size) * 3); height: calc(var(--cell-size) * 3);
            background: conic-gradient(
                from -45deg,
                var(--blue-color)   0 90deg,
                var(--yellow-color) 90deg 180deg,
                var(--green-color)  180deg 270deg,
                var(--red-color)    270deg 360deg
            );
            z-index: 1;
        }

        .cell { box-sizing: border-box; }

        .home-base {
            position: absolute;
            width: calc(var(--cell-size) * 6);
            height: calc(var(--cell-size) * 6);
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            z-index: 1; 
            border: 3px solid #2c3e50; 
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
        }
        .red-home-base { background-color: var(--red-home); }
        .green-home-base { background-color: var(--green-home); }
        .yellow-home-base { background-color: var(--yellow-home); }
        .blue-home-base { background-color: var(--blue-home); }

        .home-base-square {
            box-sizing: border-box;
            border: 2px solid rgba(44, 62, 80, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .home-spot { 
            width: calc(var(--cell-size) * 1.8);
            height: calc(var(--cell-size) * 1.8);
            border: 2px dashed rgba(0,0,0,0.2); 
            border-radius: 50%; 
            background-color: rgba(255,255,255,0.2); 
            box-sizing: border-box;
        }

        .path { background-color: #f5eadd; box-shadow: inset 0 0 8px rgba(0,0,0,0.25); }
        .start {
            background-size: 60%; background-position: center; background-repeat: no-repeat;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="white" d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>');
        }
        .start.red { background-color: var(--red-color); }
        .start.green { background-color: var(--green-color); }
        .start.yellow { background-color: var(--yellow-color); }
        .start.blue { background-color: var(--blue-color); }
        
        .safe-space {
            background-size: 60%; background-position: center; background-repeat: no-repeat;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="rgba(0,0,0,0.3)" d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>');
        }

        .finish-path.red { background-color: var(--red-color); box-shadow: inset 0 0 8px rgba(0,0,0,0.4); }
        .finish-path.green { background-color: var(--green-color); box-shadow: inset 0 0 8px rgba(0,0,0,0.4); }
        .finish-path.yellow { background-color: var(--yellow-color); box-shadow: inset 0 0 8px rgba(0,0,0,0.4); }
        .finish-path.blue { background-color: var(--blue-color); box-shadow: inset 0 0 8px rgba(0,0,0,0.4); }

        .pawn {
            position: absolute; z-index: 10;
            top: 0; left: 0; 
            width: var(--pawn-size); height: var(--pawn-size);
            border-radius: 50%; border: 2px solid rgba(255,255,255,0.8);
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            will-change: transform;
            transition: transform var(--hop-duration) cubic-bezier(0.34, 1.56, 0.64, 1), z-index 0s 0.1s;
            display: flex; justify-content: center; align-items: center;
            font-size: calc(var(--pawn-size) * 0.6); font-weight: bold;
            color: white; text-shadow: 1px 1px 2px black;
        }
        
        .pawn.hopping {
            transform: var(--pawn-transform) translateY(calc(var(--pawn-size) * -1)) scale(1.2);
            z-index: 14 !important; /* Increased to always be on top during animation */
        }

        .pawn.red { background: radial-gradient(circle at 30% 30%, #e55039, #c0392b); }
        .pawn.green { background: radial-gradient(circle at 30% 30%, #1dd1a1, #00b894); }
        .pawn.yellow { background: radial-gradient(circle at 30% 30%, #feca57, #f39c12); }
        .pawn.blue { background: radial-gradient(circle at 30% 30%, #48dbfb, #0984e3); }
        
        .pawn.movable { cursor: pointer; animation: pulse-glow 1.5s infinite; }
        
        .pawn.movable::after {
            content: '';
            position: absolute;
            top: -10%; left: -10%;
            width: 120%; height: 120%;
            background-color: var(--current-player-color-glow);
            border-radius: 50%;
            z-index: -1;
            opacity: 0;
            animation: pulse-glow-after 1.5s infinite;
        }

        #game-info {
            display: flex; flex-direction: column; align-items: center;
            background-color: rgba(44, 62, 80, 0.8); padding: 20px; border-radius: 15px;
            width: 280px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            perspective: 800px;
        }
        #status { font-size: 1.2em; text-align: center; min-height: 50px; margin-bottom: 20px; }
        #dice {
            width: 80px; height: 80px; background-color: #fff; border-radius: 10px;
            display: flex; justify-content: center; align-items: center;
            font-size: 3em; color: #333; cursor: pointer; border: 4px solid transparent;
            transition: transform 0.3s, border-color 0.3s; 
            box-shadow: 0 5px 10px rgba(0,0,0,0.2);
            transform-style: preserve-3d;
        }
        #dice.active { border-color: var(--current-player-color); animation: jiggle 0.5s; }
        #dice.rolling { animation: roll-dice-animation 0.5s ease-out; }

        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center; }
        .modal-content {
            background-color: #34495e; 
            color: #ecf0f1; 
            margin: auto;
            padding: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2); 
            width: 90%;
            max-width: 550px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4); 
        }
        
        #main-menu { display: flex; }
        #main-menu h2 { margin-top: 0; color: #3498db; }
        #main-menu p { margin-bottom: 25px; color: #bdc3c7; }
        .menu-section { margin-bottom: 25px; }

        #player-setup-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .player-setup-row {
            display: grid;
            grid-template-columns: 1fr 1.2fr 2fr;
            gap: 15px;
            align-items: center;
            padding: 10px 15px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 8px;
            border: 1px solid transparent;
            transition: all 0.3s;
        }
        .player-setup-row.inactive {
            opacity: 0.5;
            background-color: transparent;
        }
        .player-info { font-weight: bold; color: #fff; text-align: left; }
        .player-type-selector select {
            width: 100%;
            padding: 8px;
            background-color: #2c3e50;
            color: #ecf0f1;
            border: 1px solid #7f8c8d;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
        }
        .player-type-selector select:focus { outline: none; border-color: #3498db; }
        .color-options { display: flex; gap: 10px; justify-content: flex-end; }
        .color-choice { width: 35px; height: 35px; border-radius: 50%; cursor: pointer; border: 4px solid transparent; transition: all 0.2s; }
        .color-choice.red { background-color: var(--red-color); }
        .color-choice.green { background-color: var(--green-color); }
        .color-choice.yellow { background-color: var(--yellow-color); }
        .color-choice.blue { background-color: var(--blue-color); }
        .color-choice:hover { transform: scale(1.1); }
        .color-choice.selected { border-color: #3498db; box-shadow: 0 0 10px #3498db; transform: scale(1.1); }
        .color-choice.taken { cursor: not-allowed; opacity: 0.3; transform: scale(0.9); }
        .player-setup-row.inactive .color-choice { cursor: not-allowed; opacity: 0.3; }
        
        #start-game-btn { padding: 12px 30px; font-size: 1.2em; background-color: #27ae60; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.3s, transform 0.2s; }
        #start-game-btn:disabled { background-color: #95a5a6; cursor: not-allowed; }
        #start-game-btn:not(:disabled):hover { background-color: #2ecc71; transform: translateY(-2px); }

        @keyframes pulse-glow-after { 0%, 100% { transform: scale(0.8); opacity: 0; } 50% { transform: scale(1); opacity: 0.7; } }
        @keyframes pulse-glow {}
        @keyframes roll-dice-animation { 0% { transform: scale(1.1) rotate(0deg); } 50% { transform: scale(1.3) rotate(180deg); } 100% { transform: scale(1) rotate(360deg); } }
        @keyframes jiggle { 0%, 100% { transform: scale(1) rotate(0deg); } 25% { transform: scale(1.05) rotate(-5deg); } 75% { transform: scale(1.05) rotate(5deg); } }

        @media (max-width: 850px) {
            body { padding: 10px; min-height: 0; }
            #game-container { flex-direction: column; gap: 20px; }
            #game-info { width: 100%; max-width: var(--board-size); padding: 15px; }
        }
        @media (max-width: 500px) {
            .player-setup-row { grid-template-columns: 1fr; text-align: center; }
            .player-info { text-align: center; margin-bottom: 5px; }
            .color-options { justify-content: center; }
        }
    </style>
</head>
<body>
    <div id="main-menu" class="modal">
        <div class="modal-content">
            <h2>Ludo Game Setup</h2>
            <p>Configure up to 4 players. Set each slot to Human, AI, or Inactive. At least 2 players are required.</p>
            <div class="menu-section">
                <div id="player-setup-container">
                    <!-- Player rows will be generated by JS -->
                </div>
            </div>
            <button id="start-game-btn" disabled>Start Game</button>
        </div>
    </div>

    <div id="game-container" style="display: none;">
        <div id="board"></div>
        <div id="game-info">
            <h1>Ludo</h1>
            <div id="status">Welcome! Red player, roll the dice.</div>
            <div id="dice" class="active">?</div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Game Elements ---
            const gameContainer = document.getElementById('game-container');
            const board = document.getElementById('board');
            const diceEl = document.getElementById('dice');
            const statusEl = document.getElementById('status');
            const root = document.documentElement;
            const hopSound = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');
            hopSound.volume = 0.5;

            // --- Menu Elements ---
            const mainMenu = document.getElementById('main-menu');
            const playerSetupContainer = document.getElementById('player-setup-container');
            const startGameBtn = document.getElementById('start-game-btn');

            // --- Game Constants ---
            const PLAYERS = {
                red: { color: 'var(--red-color)', glow: 'rgba(214, 48, 49, 0.7)' },
                green: { color: 'var(--green-color)', glow: 'rgba(0, 184, 148, 0.7)' },
                yellow: { color: 'var(--yellow-color)', glow: 'rgba(253, 216, 53, 0.7)' },
                blue: { color: 'var(--blue-color)', glow: 'rgba(9, 132, 227, 0.7)' }
            };
            const PLAYER_ORDER = ['red', 'green', 'yellow', 'blue'];
            const PATH_LENGTH = 51;
            const FINISH_PATH_LENGTH = 6;
            const FINAL_SQUARE_POSITION = PATH_LENGTH + FINISH_PATH_LENGTH - 1;
            const SAFE_SPACES = [8, 21, 34, 47]; // NEW: Additional safe spaces

            const PATH_DATA = {
                PATH_COORDS: [[6,1],[6,2],[6,3],[6,4],[6,5],[5,6],[4,6],[3,6],[2,6],[1,6],[0,6],[0,7],[0,8],[1,8],[2,8],[3,8],[4,8],[5,8],[6,9],[6,10],[6,11],[6,12],[6,13],[6,14],[7,14],[8,14],[8,13],[8,12],[8,11],[8,10],[8,9],[9,8],[10,8],[11,8],[12,8],[13,8],[14,8],[14,7],[14,6],[13,6],[12,6],[11,6],[10,6],[9,6],[8,5],[8,4],[8,3],[8,2],[8,1],[8,0],[7,0],[6,0]],
                FINISH_PATH_COORDS: {red:[[7,1],[7,2],[7,3],[7,4],[7,5],[7,6]],green:[[1,7],[2,7],[3,7],[4,7],[5,7],[6,7]],yellow:[[7,13],[7,12],[7,11],[7,10],[7,9],[7,8]],blue:[[13,7],[12,7],[11,7],[10,7],[9,7],[8,7]]},
                START_POSITIONS: { red: 0, green: 13, yellow: 26, blue: 39 },
                HOME_SPOTS: {red:[[1,1],[1,4],[4,1],[4,4]],green:[[1,10],[1,13],[4,10],[4,13]],yellow:[[10,10],[10,13],[13,10],[13,13]],blue:[[10,1],[10,4],[13,1],[13,4]]}
            };
            
            // --- Game State Variables ---
            let gameState = {};
            let menuState = {
                players: [
                    { id: 0, name: 'Player 1', type: 'human', color: 'red' },
                    { id: 1, name: 'Player 2', type: 'ai', color: 'green' },
                    { id: 2, name: 'Player 3', type: 'ai', color: 'yellow' },
                    { id: 3, name: 'Player 4', type: 'inactive', color: null }
                ]
            };
            let pawnElements = {};
            let cachedCellSize = 0;
            const sleep = ms => new Promise(res => setTimeout(res, ms));

            // --- Menu Logic ---
            function setupMenu() {
                mainMenu.style.display = 'flex';
                gameContainer.style.display = 'none';
                generatePlayerSetupUI();
                updateMenuUI();
                startGameBtn.addEventListener('click', () => {
                    if (startGameBtn.disabled) return;
                    mainMenu.style.display = 'none';
                    gameContainer.style.display = 'flex';
                    cachedCellSize = board.clientWidth / 15;
                    const playerTypes = {};
                    PLAYER_ORDER.forEach(color => playerTypes[color] = 'inactive');
                    menuState.players.forEach(player => {
                        if (player.type !== 'inactive' && player.color) {
                            playerTypes[player.color] = player.type;
                        }
                    });
                    initGame(playerTypes);
                });
            }
            function generatePlayerSetupUI() {
                playerSetupContainer.innerHTML = '';
                menuState.players.forEach(player => {
                    const playerRow = document.createElement('div');
                    playerRow.className = 'player-setup-row';
                    playerRow.dataset.playerId = player.id;
                    playerRow.innerHTML = `
                        <div class="player-info">${player.name}</div>
                        <div class="player-type-selector">
                            <select>
                                <option value="human">Human</option>
                                <option value="ai">AI</option>
                                <option value="inactive">Inactive</option>
                            </select>
                        </div>
                        <div class="color-options">
                            ${PLAYER_ORDER.map(color => `<div class="color-choice ${color}" data-color="${color}"></div>`).join('')}
                        </div>
                    `;
                    playerSetupContainer.appendChild(playerRow);
                    const typeSelector = playerRow.querySelector('select');
                    typeSelector.value = player.type;
                    typeSelector.addEventListener('change', (e) => {
                        const newType = e.target.value;
                        player.type = newType;
                        if (newType === 'inactive') player.color = null;
                        updateMenuUI();
                    });
                    playerRow.querySelectorAll('.color-choice').forEach(choice => {
                        choice.addEventListener('click', (e) => {
                            if (player.type === 'inactive') return;
                            const chosenColor = e.target.dataset.color;
                            const isTaken = menuState.players.some(p => p.id !== player.id && p.color === chosenColor);
                            if (isTaken) return;
                            player.color = (player.color === chosenColor) ? null : chosenColor;
                            updateMenuUI();
                        });
                    });
                });
            }
            function updateMenuUI() {
                const activeColors = menuState.players.map(p => p.color).filter(Boolean);
                document.querySelectorAll('.player-setup-row').forEach(row => {
                    const playerId = parseInt(row.dataset.playerId);
                    const player = menuState.players[playerId];
                    row.classList.toggle('inactive', player.type === 'inactive');
                    row.querySelector('select').value = player.type;
                    row.querySelectorAll('.color-choice').forEach(choice => {
                        const color = choice.dataset.color;
                        choice.classList.remove('selected', 'taken');
                        if (player.color === color) choice.classList.add('selected');
                        else if (activeColors.includes(color)) choice.classList.add('taken');
                    });
                });
                checkStartButtonState();
            }
            function checkStartButtonState() {
                const activePlayers = menuState.players.filter(p => p.type !== 'inactive');
                const allActiveHaveColor = activePlayers.every(p => p.color !== null);
                startGameBtn.disabled = !(activePlayers.length >= 2 && allActiveHaveColor);
            }

            // --- Game Initialization ---
            function initGame(playerTypes) {
                createBoardVisuals();
                gameState = {
                    playerTypes,
                    activePlayers: PLAYER_ORDER.filter(color => playerTypes[color] !== 'inactive'),
                    currentPlayerIndex: -1, diceValue: null, diceRolled: false,
                    consecutiveSixes: 0, isAnimating: false, pawns: {},
                    boardState: {}, gameWon: false, playerPersonalities: {}
                };
                const personalities = ['aggressor', 'defender', 'sprinter', 'strategist'];
                let p_idx = 0;
                gameState.activePlayers.forEach(color => {
                    if (gameState.playerTypes[color] === 'ai') {
                        gameState.playerPersonalities[color] = personalities[p_idx % personalities.length];
                        p_idx++;
                    }
                });
                document.querySelectorAll('.pawn').forEach(p => p.remove());
                pawnElements = {};
                for (const color of PLAYER_ORDER) {
                    for (let i = 0; i < 4; i++) {
                        const pawnId = `${color}-pawn-${i}`;
                        gameState.pawns[pawnId] = { id: pawnId, color: color, position: -1, isFinished: false };
                        const pawnEl = document.createElement('div');
                        pawnEl.className = `pawn ${color}`; pawnEl.id = pawnId; pawnEl.innerText = i + 1;
                        pawnEl.addEventListener('click', () => handlePawnClick(pawnId));
                        board.appendChild(pawnEl); pawnElements[pawnId] = pawnEl;
                        placePawn(pawnId, true);
                    }
                }
                diceEl.addEventListener('click', handleHumanRoll);
                switchPlayer();
            }

            // --- Visuals and Board Setup ---
            function createBoardVisuals() {
                board.innerHTML = '';
                const allCells = {};
                for (let r = 0; r < 15; r++) { for (let c = 0; c < 15; c++) {
                    const cell = document.createElement('div'); cell.className = `cell`; board.appendChild(cell); allCells[`${r}-${c}`] = cell;
                }}
                const homeBaseAreas = {
                    red:    { top: 0, left: 0, class: 'red-home-base' }, green:  { top: 0, left: 9, class: 'green-home-base' },
                    yellow: { top: 9, left: 9, class: 'yellow-home-base' }, blue:   { top: 9, left: 0, class: 'blue-home-base' }
                };
                for (const color in homeBaseAreas) {
                    const area = homeBaseAreas[color]; const homeBaseEl = document.createElement('div');
                    homeBaseEl.className = `home-base ${area.class}`; homeBaseEl.style.top = `calc(var(--cell-size) * ${area.top})`;
                    homeBaseEl.style.left = `calc(var(--cell-size) * ${area.left})`;
                    for (let i = 0; i < 4; i++) { const square = document.createElement('div'); square.className = 'home-base-square';
                        square.innerHTML = '<div class="home-spot"></div>'; homeBaseEl.appendChild(square);
                    }
                    board.appendChild(homeBaseEl);
                }
                PATH_DATA.PATH_COORDS.forEach(([r,c]) => allCells[`${r}-${c}`].classList.add('path'));
                
                // NEW: Add visual markers for safe spaces
                SAFE_SPACES.forEach(index => {
                    const [r,c] = PATH_DATA.PATH_COORDS[index];
                    allCells[`${r}-${c}`].classList.add('safe-space');
                });
                
                Object.values(PATH_DATA.FINISH_PATH_COORDS).flat().forEach(([r,c]) => allCells[`${r}-${c}`].classList.add('path'));
                Object.entries(PATH_DATA.START_POSITIONS).forEach(([color, index]) => {
                    const [r,c] = PATH_DATA.PATH_COORDS[index]; allCells[`${r}-${c}`].classList.add('start', color);
                });
                Object.entries(PATH_DATA.FINISH_PATH_COORDS).forEach(([color, coords]) => coords.forEach(([r,c]) => allCells[`${r}-${c}`].classList.add('finish-path', color)));
            }
            function updateBoardState(pawnId, oldPos, newPos) {
                const pawn = gameState.pawns[pawnId];
                const oldGlobal = getGlobalPathIndex(pawn.color, oldPos);
                const newGlobal = getGlobalPathIndex(pawn.color, newPos);
                if (oldGlobal !== null && gameState.boardState[oldGlobal]) {
                    gameState.boardState[oldGlobal] = gameState.boardState[oldGlobal].filter(id => id !== pawnId);
                    if (gameState.boardState[oldGlobal].length === 0) delete gameState.boardState[oldGlobal];
                }
                if (newGlobal !== null) {
                    if (!gameState.boardState[newGlobal]) gameState.boardState[newGlobal] = [];
                    if (!gameState.boardState[newGlobal].includes(pawnId)) gameState.boardState[newGlobal].push(pawnId);
                }
            }
            function placePawn(pawnId, noTransition = false, positionOverride = null) {
                const pawnEl = pawnElements[pawnId];
                if (noTransition) pawnEl.style.transition = 'none';
                const [x, y] = getPawnTranslate(pawnId, positionOverride);
                const transformString = `translate(${x}px, ${y}px)`;
                pawnEl.style.transform = transformString;
                pawnEl.style.setProperty('--pawn-transform', transformString);
                if (noTransition) { pawnEl.offsetHeight; pawnEl.style.transition = ''; }
            }
            function updateStackingForSquare(globalIndex) {
                if (globalIndex === null || !gameState.boardState[globalIndex]) return;
                gameState.boardState[globalIndex].forEach(pawnId => placePawn(pawnId));
            }
            function getPawnTranslate(pawnId, positionOverride = null) {
                const { color, isFinished } = gameState.pawns[pawnId];
                const position = positionOverride ?? gameState.pawns[pawnId].position;
                const pawnSize = cachedCellSize * 0.7;
                const centerOffset = (cachedCellSize - pawnSize) / 2;
                if (position === -1) {
                    const homeIndex = parseInt(pawnId.slice(-1));
                    const [row, col] = PATH_DATA.HOME_SPOTS[color][homeIndex];
                    return [col * cachedCellSize + centerOffset, row * cachedCellSize + centerOffset];
                }
                if (isFinished) { return [7 * cachedCellSize + centerOffset, 7 * cachedCellSize + centerOffset]; }
                let coords;
                if (position >= PATH_LENGTH) { coords = PATH_DATA.FINISH_PATH_COORDS[color][position - PATH_LENGTH];
                } else { coords = PATH_DATA.PATH_COORDS[getGlobalPathIndex(color, position)]; }
                if (!coords) { console.error(`Invalid coordinates for ${pawnId} at pos ${position}`); return [0, 0]; }
                let offset = 0;
                const globalIndex = getGlobalPathIndex(color, position);
                if (positionOverride === null && globalIndex !== null) {
                    const pawnsOnSquare = gameState.boardState[globalIndex] || [];
                    const stackIndex = pawnsOnSquare.indexOf(pawnId);
                    if (stackIndex > 0) { offset = (pawnSize * 0.15) * stackIndex; }
                }
                return [coords[1] * cachedCellSize + centerOffset + offset, coords[0] * cachedCellSize + centerOffset + offset];
            }
            const getGlobalPathIndex = (color, position) => {
                if(position === null || position < 0 || position >= PATH_LENGTH) return null;
                return (PATH_DATA.START_POSITIONS[color] + position) % 52;
            }

            // --- Core Game Loop & Player Actions ---
            async function handleHumanRoll() {
                if (gameState.isAnimating || gameState.diceRolled) return;
                await processRoll();
            }
            async function processRoll() {
                await rollDice();
                if (gameState.consecutiveSixes === 3) {
                    updateStatus(`Rolled 3 sixes! Turn forfeited.`);
                    await sleep(1500);
                    endTurn(false); return;
                }
                const movablePawns = findMovablePawns();
                if (movablePawns.length > 0) {
                    const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
                    if (gameState.playerTypes[currentPlayer] === 'human') {
                        movablePawns.forEach(pawnId => pawnElements[pawnId].classList.add('movable'));
                    } else {
                        await sleep(500);
                        const personality = gameState.playerPersonalities[currentPlayer] || 'strategist';
                        const bestPawnId = aiChooseBestMove(movablePawns, personality);
                        await makeMove(bestPawnId);
                    }
                } else {
                    updateStatus(statusEl.innerHTML + " No possible moves.");
                    gameState.isAnimating = true;
                    await sleep(1200);
                    endTurn(gameState.diceValue === 6);
                }
            }
            async function handlePawnClick(pawnId) {
                const pawnEl = pawnElements[pawnId];
                const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
                if (gameState.isAnimating || gameState.playerTypes[currentPlayer] === 'ai' || !pawnEl.classList.contains('movable')) return;
                document.querySelectorAll('.movable').forEach(el => el.classList.remove('movable'));
                await makeMove(pawnId);
            }
            async function makeMove(pawnId) {
                gameState.isAnimating = true;
                const pawn = gameState.pawns[pawnId];
                const oldPosition = pawn.position;
                const oldGlobalIndex = getGlobalPathIndex(pawn.color, oldPosition);
                await movePawnWithAnimation(pawnId);
                const newGlobalIndex = getGlobalPathIndex(pawn.color, pawn.position);
                updateBoardState(pawnId, oldPosition, pawn.position);
                if (oldGlobalIndex !== null) updateStackingForSquare(oldGlobalIndex);
                if (newGlobalIndex !== null) updateStackingForSquare(newGlobalIndex);
                const captureInfo = checkForCapture(pawn);
                if (captureInfo.captured) { updateStackingForSquare(captureInfo.victimGlobalIndex); }
                checkForWin();
                await endTurn(gameState.diceValue === 6 || captureInfo.captured);
            }
            async function rollDice() {
                diceEl.classList.add('rolling'); gameState.diceRolled = true; gameState.isAnimating = true;
                const numberFlipper = setInterval(() => { diceEl.innerText = Math.floor(Math.random() * 6) + 1; }, 60);
                await sleep(500); clearInterval(numberFlipper);
                gameState.diceValue = Math.floor(Math.random() * 6) + 1;
                gameState.consecutiveSixes = (gameState.diceValue === 6) ? gameState.consecutiveSixes + 1 : 0;
                diceEl.innerText = gameState.diceValue; diceEl.classList.remove('rolling', 'active');
                updateStatus(); await sleep(200); gameState.isAnimating = false;
            }
            function findMovablePawns() {
                const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
                const dice = gameState.diceValue;
                return Object.values(gameState.pawns).filter(pawn => {
                    if (pawn.color !== currentPlayer || pawn.isFinished) return false;
                    if (pawn.position === -1) return dice === 6;
                    return (pawn.position + dice) <= FINAL_SQUARE_POSITION;
                }).map(pawn => pawn.id);
            }
            async function movePawnWithAnimation(pawnId) {
                const pawn = gameState.pawns[pawnId]; const pawnEl = pawnElements[pawnId];
                const startPos = pawn.position; const dice = gameState.diceValue; const hopDelay = 500;
                const playHopSound = () => { if (hopSound.readyState >= 2) { hopSound.currentTime = 0; hopSound.play(); }};
                if (startPos === -1 && dice === 6) {
                    pawn.position = 0; placePawn(pawnId, false, 0); await sleep(50);
                    pawnEl.classList.add('hopping'); playHopSound();
                    await sleep(hopDelay + 50); pawnEl.classList.remove('hopping');
                } else {
                    for (let i = 1; i <= dice; i++) {
                        const tempVisualPosition = startPos + i;
                        placePawn(pawnId, false, tempVisualPosition); await sleep(10);
                        pawnEl.classList.add('hopping'); playHopSound();
                        await sleep(tempVisualPosition >= PATH_LENGTH ? hopDelay + 50 : hopDelay);
                        pawnEl.classList.remove('hopping');
                    }
                    pawn.position = startPos + dice;
                }
                if (pawn.position === FINAL_SQUARE_POSITION) { pawn.isFinished = true; }
                placePawn(pawnId); await sleep(100);
            }
            function checkForCapture(movedPawn) {
                const movedGlobalIndex = getGlobalPathIndex(movedPawn.color, movedPawn.position);
                
                // UPDATED: Added check for new and old safe spaces
                const isStartSquare = Object.values(PATH_DATA.START_POSITIONS).includes(movedGlobalIndex);
                const isSafeSquare = SAFE_SPACES.includes(movedGlobalIndex);

                if (movedPawn.isFinished || movedPawn.position < 0 || movedPawn.position >= PATH_LENGTH || isStartSquare || isSafeSquare) {
                    return { captured: false };
                }

                const victims = (gameState.boardState[movedGlobalIndex] || []).filter(id => gameState.pawns[id].color !== movedPawn.color);
                if (victims.length === 0) return { captured: false };
                let victimGlobalIndex = -1;
                victims.forEach(victimId => {
                    const victimPawn = gameState.pawns[victimId];
                    updateStatus(`${movedPawn.color.toUpperCase()} captured ${victimPawn.color.toUpperCase()}'s pawn!`);
                    const oldPos = victimPawn.position;
                    victimGlobalIndex = getGlobalPathIndex(victimPawn.color, oldPos);
                    victimPawn.position = -1; updateBoardState(victimId, oldPos, -1); placePawn(victimId);
                });
                return { captured: true, victimGlobalIndex: victimGlobalIndex };
            }
            function checkForWin() {
                const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
                const allFinished = Object.values(gameState.pawns).filter(p => p.color === currentPlayer).every(p => p.isFinished);
                if (allFinished) {
                    statusEl.innerHTML = `<h2 style="color:${PLAYERS[currentPlayer].color}; text-shadow: 1px 1px 5px black;">${currentPlayer.toUpperCase()} WINS!</h2>`;
                    diceEl.removeEventListener('click', handleHumanRoll);
                    diceEl.classList.remove('active'); diceEl.style.cursor = 'default'; gameState.gameWon = true;
                }
            }
            async function endTurn(getsExtraRoll) {
                if (gameState.gameWon) return;
                if (getsExtraRoll) {
                    gameState.diceRolled = false; gameState.isAnimating = false;
                    const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
                    let message = (gameState.diceValue === 6) ? `Rolled a 6!` : `Bonus turn!`;
                    updateStatus(`${message} <strong style="color:${PLAYERS[currentPlayer].color}">${currentPlayer.toUpperCase()}</strong>, roll again.`);
                    if (gameState.playerTypes[currentPlayer] === 'ai') {
                        diceEl.style.pointerEvents = 'none';
                        await sleep(1000); executeAITurn();
                    } else {
                        diceEl.style.pointerEvents = 'auto'; diceEl.classList.add("active");
                    }
                } else { await sleep(500); switchPlayer(); }
            }
            // NEW: Function to manage pawn z-index for clickability
            function updatePawnZIndices() {
                if (gameState.gameWon || !gameState.activePlayers.length || gameState.currentPlayerIndex < 0) return;
                const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
                
                Object.values(pawnElements).forEach(pawnEl => {
                    const pawnColor = pawnEl.id.split('-')[0];
                    // Active player's pawns get a higher z-index (12) to be clickable, others get base (10)
                    pawnEl.style.zIndex = (pawnColor === currentPlayer) ? 12 : 10;
                });
            }
            function switchPlayer() {
                if (gameState.gameWon) return;
                gameState.isAnimating = false; gameState.diceRolled = false;
                gameState.diceValue = null; gameState.consecutiveSixes = 0;
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.activePlayers.length;
                
                updatePawnZIndices(); // NEW: Update z-indices for the new player

                const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
                updateStatus();
                if (gameState.playerTypes[currentPlayer] === 'ai') {
                    diceEl.style.pointerEvents = 'none'; setTimeout(executeAITurn, 1000);
                } else { diceEl.style.pointerEvents = 'auto'; }
            }
            function updateStatus(message = "") {
                if (gameState.gameWon || !gameState.activePlayers.length) return;
                const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
                if (!currentPlayer) return;
                const playerInfo = PLAYERS[currentPlayer];
                const playerType = gameState.playerTypes[currentPlayer];
                let personalityText = '';
                if(playerType === 'ai') {
                    const personality = gameState.playerPersonalities[currentPlayer];
                    personalityText = ` (${personality.charAt(0).toUpperCase() + personality.slice(1)})`;
                }
                statusEl.innerHTML = message ? message : playerType === 'ai' 
                    ? `<strong style="color:${playerInfo.color}">${currentPlayer.toUpperCase()} (AI${personalityText})</strong> is thinking...`
                    : `It's <strong style="color:${playerInfo.color}">${currentPlayer.toUpperCase()}</strong>'s turn. Roll the dice!`;
                diceEl.innerText = gameState.diceValue || "?";
                diceEl.style.setProperty("--current-player-color", playerInfo.color);
                root.style.setProperty("--current-player-color-glow", playerInfo.glow);
                if (!gameState.diceRolled && playerType === 'human' && !gameState.gameWon) {
                    diceEl.classList.add("active");
                } else {
                    diceEl.classList.remove("active");
                }
            }
            async function executeAITurn() {
                if (gameState.gameWon || gameState.isAnimating) return;
                gameState.isAnimating = true; updateStatus();
                await sleep(800); await processRoll();
                gameState.isAnimating = false;
            }

            // --- Advanced AI Helper Functions ---
            const getGamePhase = (color) => {
                const myPawns = Object.values(gameState.pawns).filter(p => p.color === color);
                const finishedCount = myPawns.filter(p => p.isFinished).length;
                const onHomePathCount = myPawns.filter(p => p.position >= PATH_LENGTH && !p.isFinished).length;
                const onBoardCount = myPawns.filter(p => p.position > -1).length;

                if (finishedCount >= 3 || onHomePathCount > 0) return 'late';
                if (onBoardCount <= 1) return 'early';
                return 'mid';
            };
            const calculateThreatScore = (color) => {
                const pawns = Object.values(gameState.pawns).filter(p => p.color === color);
                let threatScore = 0;
                for (const pawn of pawns) {
                    if (pawn.isFinished) threatScore += 100;
                    else if (pawn.position >= PATH_LENGTH) threatScore += 50;
                    else if (pawn.position > -1) threatScore += pawn.position;
                }
                return threatScore;
            };
            const getNextPlayerColor = () => {
                const nextIndex = (gameState.currentPlayerIndex + 1) % gameState.activePlayers.length;
                return gameState.activePlayers[nextIndex];
            };
            const canOpponentCaptureOnNextTurn = (opponentColor, targetGlobalIndex, diceRoll) => {
                if (targetGlobalIndex === null) return false;
                const opponentPawns = Object.values(gameState.pawns).filter(p => p.color === opponentColor && p.position > -1 && !p.isFinished);
                for (const oppPawn of opponentPawns) {
                    const newPos = oppPawn.position + diceRoll;
                    if (newPos < PATH_LENGTH) {
                        const newGlobal = getGlobalPathIndex(opponentColor, newPos);
                        if (newGlobal === targetGlobalIndex) return true;
                    }
                }
                return false;
            };
            
            // --- UPDATED: Advanced AI Logic ---
            function aiChooseBestMove(movablePawns, personality = 'strategist') {
                const dice = gameState.diceValue;
                let bestMove = { pawnId: null, score: -Infinity };
                const myColor = gameState.pawns[movablePawns[0]].color;
                const myPawns = Object.values(gameState.pawns).filter(p => p.color === myColor && !p.isFinished);

                const baseWeights = {
                    progress: 1, finish: 1000, enterHomePath: 150, capture: 200,
                    captureThreatMultiplier: 0.5, // Bonus points for capturing a player in the lead
                    moveFromHome: 100, safeLanding: 80, escapeThreat: 70, 
                    riskPenalty: -90, // Penalty for landing on a dangerous square
                    lookaheadPenaltyMultiplier: 2.5, // Multiplier for how bad an immediate predictable capture is
                    clusterPenalty: -30, ladderBonus: 25, // Bonus for creating a supportive chain
                };

                let weights = { ...baseWeights };
                switch (personality) {
                    case 'aggressor':
                        weights.capture *= 1.75; weights.riskPenalty *= 0.5; break;
                    case 'defender':
                        weights.safeLanding *= 2; weights.riskPenalty *= 2.5;
                        weights.escapeThreat *= 1.5; weights.capture *= 0.75; break;
                    case 'sprinter':
                        weights.progress *= 2; weights.finish *= 1.2;
                        weights.moveFromHome *= 0.8; break;
                }

                const gamePhase = getGamePhase(myColor);
                if (gamePhase === 'early') {
                    weights.moveFromHome *= 1.5; weights.capture *= 0.7;
                } else if (gamePhase === 'late') {
                    weights.progress *= 3; weights.finish *= 2;
                    weights.capture *= 0.5; weights.riskPenalty *= 1.5;
                }

                const isSquareInDanger = (globalIndex, color) => {
                    if (globalIndex === null || Object.values(PATH_DATA.START_POSITIONS).includes(globalIndex) || SAFE_SPACES.includes(globalIndex)) return false;
                    for (const opp of gameState.activePlayers) {
                        if (opp === color) continue;
                        for (let d = 1; d <= 6; d++) {
                            if (canOpponentCaptureOnNextTurn(opp, globalIndex, d)) return true;
                        }
                    }
                    return false;
                };
                
                for (const pawnId of movablePawns) {
                    const pawn = gameState.pawns[pawnId];
                    const currentPos = pawn.position;
                    const newPos = (currentPos === -1) ? 0 : currentPos + dice;
                    let score = 0;

                    score += newPos * weights.progress;
                    if (newPos === FINAL_SQUARE_POSITION) score += weights.finish;
                    if (currentPos < PATH_LENGTH && newPos >= PATH_LENGTH) score += weights.enterHomePath;
                    if (currentPos === -1 && dice === 6) score += weights.moveFromHome;
                    
                    const newGlobalIndex = getGlobalPathIndex(myColor, newPos);
                    // UPDATED: isPermanentlySafe now includes start squares and new safe spaces
                    const isPermanentlySafe = newGlobalIndex !== null && (Object.values(PATH_DATA.START_POSITIONS).includes(newGlobalIndex) || SAFE_SPACES.includes(newGlobalIndex));

                    if (newGlobalIndex !== null) {
                        const opponentsOnSquare = (gameState.boardState[newGlobalIndex] || []).filter(id => gameState.pawns[id].color !== myColor);
                        if (!isPermanentlySafe && opponentsOnSquare.length > 0) {
                            const victimPawn = gameState.pawns[opponentsOnSquare[0]];
                            const victimThreat = calculateThreatScore(victimPawn.color);
                            score += weights.capture + (victimThreat * weights.captureThreatMultiplier);
                        }
                        
                        const nextPlayerColor = getNextPlayerColor();
                        let lookaheadPenalty = 0;
                        for (let d = 1; d <= 6; d++) {
                            if (canOpponentCaptureOnNextTurn(nextPlayerColor, newGlobalIndex, d)) {
                                lookaheadPenalty += weights.riskPenalty * weights.lookaheadPenaltyMultiplier;
                            }
                        }
                        score += (lookaheadPenalty / 6);

                        // REVISED LOGIC: Give full bonus for permanent safety, half for temporary safety.
                        if (isPermanentlySafe) {
                            score += weights.safeLanding;
                        } else if (!isSquareInDanger(newGlobalIndex, myColor)) {
                            score += weights.safeLanding / 2;
                        }
                    }

                    const currentGlobalIndex = getGlobalPathIndex(myColor, currentPos);
                    if (currentGlobalIndex !== null && isSquareInDanger(currentGlobalIndex, myColor)) {
                        score += weights.escapeThreat * (1 + pawn.position / PATH_LENGTH);
                    }

                    myPawns.forEach(otherPawn => {
                        if (otherPawn.id !== pawnId && otherPawn.position > -1) {
                            const distance = newPos - otherPawn.position;
                            if (distance >= 2 && distance <= 6) {
                                score += weights.ladderBonus;
                            }
                        }
                    });

                    if (bestMove.pawnId === null || score > bestMove.score) {
                        bestMove = { pawnId, score };
                    }
                }
                
                return bestMove.pawnId || movablePawns[0];
            }
            
            setupMenu();
        });
    </script>
</body>
</html>

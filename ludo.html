<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ludo</title>
    <style>
        :root {
            --board-size: clamp(320px, 90vmin, 650px);
            --cell-size: calc(var(--board-size) / 15);
            --pawn-size: calc(var(--cell-size) * 0.7);
            /* --- CHANGE: Slightly faster hop for a snappier feel --- */
            --hop-duration: 0.15s;

            --red-color: #d63031;
            --green-color: #00b894;
            --yellow-color: #fdd835;
            --blue-color: #0984e3;

            --red-home: #e17055;
            --green-home: #55efc4;
            --yellow-home: #ffeaa7;
            --blue-home: #74b9ff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2c3e50;
            background-image: radial-gradient(circle, #34495e, #2c3e50);
            color: #fff;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            /* --- OPTIMIZATION: Improve rendering performance on mobile --- */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #game-container {
            display: flex;
            flex-direction: row;
            justify-content: center;
            gap: 30px;
            align-items: center;
            width: 100%;
        }

        #board {
            width: var(--board-size);
            height: var(--board-size);
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            border: 10px solid #634832;
            border-radius: 15px;
            background-color: #c89666;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 80 80"><rect width="80" height="80" fill="%23c89666"/><path d="M 0,10 C 20,0, 40,0, 60,10 C 80,20, 80,30, 80,40 C 70,60, 60,80, 40,80 C 20,80, 0,60, 0,40z" fill-opacity="0.1" fill="%235a3a22"/><path d="M 80,10 C 60,0, 40,0, 20,10 C 0,20, 0,30, 0,40 C 10,60, 20,80, 40,80 C 60,80, 80,60, 80,40z" fill-opacity="0.1" fill="%235a3a22"/></svg>');
            box-shadow: 0 15px 30px rgba(0,0,0,0.5), inset 0 0 10px rgba(0,0,0,0.3);
            position: relative;
            flex-shrink: 0;
        }
        
        #board::before {
            content: '';
            position: absolute;
            top: calc(var(--cell-size) * 6); left: calc(var(--cell-size) * 6);
            width: calc(var(--cell-size) * 3); height: calc(var(--cell-size) * 3);
            background: conic-gradient(
                from -45deg,
                var(--blue-color)   0 90deg,
                var(--yellow-color) 90deg 180deg,
                var(--green-color)  180deg 270deg,
                var(--red-color)    270deg 360deg
            );
            z-index: 1;
        }

        .cell { box-sizing: border-box; }

        .home-base {
            position: absolute;
            width: calc(var(--cell-size) * 6);
            height: calc(var(--cell-size) * 6);
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            z-index: 1; 
            border: 3px solid #2c3e50; 
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
        }
        .red-home-base { background-color: var(--red-home); }
        .green-home-base { background-color: var(--green-home); }
        .yellow-home-base { background-color: var(--yellow-home); }
        .blue-home-base { background-color: var(--blue-home); }

        .home-base-square {
            box-sizing: border-box;
            border: 2px solid rgba(44, 62, 80, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .home-spot { 
            width: calc(var(--cell-size) * 1.8);
            height: calc(var(--cell-size) * 1.8);
            border: 2px dashed rgba(0,0,0,0.2); 
            border-radius: 50%; 
            background-color: rgba(255,255,255,0.2); 
            box-sizing: border-box;
        }

        .path { background-color: #f5eadd; box-shadow: inset 0 0 8px rgba(0,0,0,0.25); }
        .start {
            background-size: 60%; background-position: center; background-repeat: no-repeat;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="white" d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>');
        }
        .start.red { background-color: var(--red-color); }
        .start.green { background-color: var(--green-color); }
        .start.yellow { background-color: var(--yellow-color); }
        .start.blue { background-color: var(--blue-color); }

        .finish-path.red { background-color: var(--red-color); box-shadow: inset 0 0 8px rgba(0,0,0,0.4); }
        .finish-path.green { background-color: var(--green-color); box-shadow: inset 0 0 8px rgba(0,0,0,0.4); }
        .finish-path.yellow { background-color: var(--yellow-color); box-shadow: inset 0 0 8px rgba(0,0,0,0.4); }
        .finish-path.blue { background-color: var(--blue-color); box-shadow: inset 0 0 8px rgba(0,0,0,0.4); }

        .pawn {
            position: absolute; z-index: 10;
            top: 0; left: 0; 
            width: var(--pawn-size); height: var(--pawn-size);
            border-radius: 50%; border: 2px solid rgba(255,255,255,0.8);
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            /* --- OPTIMIZATION: will-change hints the browser about upcoming transform changes, allowing for optimizations. --- */
            will-change: transform;
            transition: transform var(--hop-duration) cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex; justify-content: center; align-items: center;
            font-size: calc(var(--pawn-size) * 0.6); font-weight: bold;
            color: white; text-shadow: 1px 1px 2px black;
        }
        
        .pawn.hopping {
            /* --- OPTIMIZATION: The hop effect is now only a transform. Animating box-shadow is very slow, so it has been removed. --- */
            transform: var(--pawn-transform) translateY(calc(var(--pawn-size) * -1)) scale(1.2);
            z-index: 11; /* Bring hopping pawn to front */
        }

        .pawn.red { background: radial-gradient(circle at 30% 30%, #e55039, #c0392b); }
        .pawn.green { background: radial-gradient(circle at 30% 30%, #1dd1a1, #00b894); }
        .pawn.yellow { background: radial-gradient(circle at 30% 30%, #feca57, #f39c12); }
        .pawn.blue { background: radial-gradient(circle at 30% 30%, #48dbfb, #0984e3); }
        
        .pawn.movable { cursor: pointer; animation: pulse-glow 1.5s infinite; }
        
        .pawn.movable::after {
            content: '';
            position: absolute;
            top: -10%; left: -10%;
            width: 120%; height: 120%;
            background-color: var(--current-player-color-glow);
            border-radius: 50%;
            z-index: -1;
            opacity: 0;
            animation: pulse-glow-after 1.5s infinite;
        }

        #game-info {
            display: flex; flex-direction: column; align-items: center;
            background-color: rgba(44, 62, 80, 0.8); padding: 20px; border-radius: 15px;
            width: 280px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            perspective: 800px;
        }
        #status { font-size: 1.2em; text-align: center; min-height: 50px; margin-bottom: 20px; }
        #dice {
            width: 80px; height: 80px; background-color: #fff; border-radius: 10px;
            display: flex; justify-content: center; align-items: center;
            font-size: 3em; color: #333; cursor: pointer; border: 4px solid transparent;
            transition: transform 0.3s, border-color 0.3s; 
            box-shadow: 0 5px 10px rgba(0,0,0,0.2);
            transform-style: preserve-3d;
        }
        #dice.active { border-color: var(--current-player-color); animation: jiggle 0.5s; }
        #dice.rolling { animation: roll-dice-animation 0.5s ease-out; }

        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center; }
        .modal-content {
            background-color: #34495e; 
            color: #ecf0f1; 
            margin: auto;
            padding: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2); 
            width: 90%;
            max-width: 500px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4); 
        }
        
        #main-menu { display: flex; }
        .menu-section { margin-bottom: 25px; }
        .menu-section h3 { margin-bottom: 15px; color: #bdc3c7; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; font-weight: 300; }
        .player-count-selector label { margin: 0 10px; font-size: 1.2em; cursor: pointer; }
        .player-color-selectors { display: flex; flex-direction: column; gap: 15px; }
        .player-selector { display: flex; justify-content: space-between; align-items: center; padding: 15px; background-color: rgba(0,0,0,0.25); border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); }
        .player-selector span { font-weight: bold; color: #fff; }
        .color-options { display: flex; gap: 10px; }
        .color-choice { width: 40px; height: 40px; border-radius: 50%; cursor: pointer; border: 4px solid transparent; transition: all 0.2s; }
        
        .color-choice.red { background-color: var(--red-color); }
        .color-choice.green { background-color: var(--green-color); }
        .color-choice.yellow { background-color: var(--yellow-color); }
        .color-choice.blue { background-color: var(--blue-color); }

        .color-choice:hover { transform: scale(1.1); }
        .color-choice.selected { border-color: #3498db; box-shadow: 0 0 10px #3498db; }
        .color-choice.taken { cursor: not-allowed; opacity: 0.3; transform: scale(0.9); }
        
        #start-game-btn { padding: 12px 30px; font-size: 1.2em; background-color: #27ae60; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.3s; }
        #start-game-btn:disabled { background-color: #95a5a6; cursor: not-allowed; }
        #start-game-btn:not(:disabled):hover { background-color: #2ecc71; }

        @keyframes pulse-glow-after {
            0%, 100% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1); opacity: 0.7; }
        }
        
        @keyframes pulse-glow {}

        @keyframes roll-dice-animation {
            0% { transform: scale(1.2) rotate3d(0, 0, 0, 0deg); }
            20% { transform: scale(1.2) rotate3d(0.5, 0.8, 0.1, 100deg); }
            40% { transform: scale(1.2) rotate3d(0.1, 0.2, 0.7, 200deg); }
            60% { transform: scale(1.2) rotate3d(0.9, 0.1, 0.3, 300deg); }
            80% { transform: scale(1.2) rotate3d(0.7, 0.3, 0.8, 400deg); }
            100% { transform: scale(1) rotate3d(0, 0, 0, 0deg); }
        }
        @keyframes jiggle {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.05) rotate(-5deg); }
            75% { transform: scale(1.05) rotate(5deg); }
        }

        @media (max-width: 850px) {
            body { padding: 10px; min-height: 0; }
            #game-container { flex-direction: column; gap: 20px; }
            #game-info { width: 100%; max-width: var(--board-size); padding: 15px; }
        }
    </style>
</head>
<body>
    <div id="main-menu" class="modal">
        <div class="modal-content">
            <h2>Welcome to Ludo!</h2>
            <div class="menu-section">
                <h3>How many human players?</h3>
                <div class="player-count-selector">
                    <label><input type="radio" name="player-count" value="1" checked> 1</label>
                    <label><input type="radio" name="player-count" value="2"> 2</label>
                    <label><input type="radio" name="player-count" value="3"> 3</label>
                    <label><input type="radio" name="player-count" value="4"> 4</label>
                </div>
            </div>
            <div class="menu-section">
                <h3>Choose your colors:</h3>
                <div id="player-color-selectors" class="player-color-selectors"></div>
            </div>
            <button id="start-game-btn" disabled>Start Game</button>
        </div>
    </div>

    <div id="game-container" style="display: none;">
        <div id="board"></div>
        <div id="game-info">
            <h1>Ludo</h1>
            <div id="status">Welcome! Red player, roll the dice.</div>
            <div id="dice" class="active">?</div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Game Elements ---
            const gameContainer = document.getElementById('game-container');
            const board = document.getElementById('board');
            const diceEl = document.getElementById('dice');
            const statusEl = document.getElementById('status');
            const root = document.documentElement;
            const hopSound = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');
            hopSound.volume = 0.5;

            // --- Menu Elements ---
            const mainMenu = document.getElementById('main-menu');
            const playerCountSelector = document.querySelector('.player-count-selector');
            const playerColorSelectorsContainer = document.getElementById('player-color-selectors');
            const startGameBtn = document.getElementById('start-game-btn');

            // --- Game Constants ---
            const PLAYERS = {
                red: { color: 'var(--red-color)', glow: 'rgba(214, 48, 49, 0.7)' },
                green: { color: 'var(--green-color)', glow: 'rgba(0, 184, 148, 0.7)' },
                yellow: { color: 'var(--yellow-color)', glow: 'rgba(253, 216, 53, 0.7)' },
                blue: { color: 'var(--blue-color)', glow: 'rgba(9, 132, 227, 0.7)' }
            };
            const PLAYER_ORDER = ['red', 'green', 'yellow', 'blue'];
            const PATH_LENGTH = 52;
            const FINISH_PATH_LENGTH = 6;
            const FINAL_SQUARE_POSITION = PATH_LENGTH + FINISH_PATH_LENGTH - 1;

            const PATH_DATA = {
                PATH_COORDS: [[6,1],[6,2],[6,3],[6,4],[6,5],[5,6],[4,6],[3,6],[2,6],[1,6],[0,6],[0,7],[0,8],[1,8],[2,8],[3,8],[4,8],[5,8],[6,9],[6,10],[6,11],[6,12],[6,13],[6,14],[7,14],[8,14],[8,13],[8,12],[8,11],[8,10],[8,9],[9,8],[10,8],[11,8],[12,8],[13,8],[14,8],[14,7],[14,6],[13,6],[12,6],[11,6],[10,6],[9,6],[8,5],[8,4],[8,3],[8,2],[8,1],[8,0],[7,0],[6,0]],
                FINISH_PATH_COORDS: {red:[[7,1],[7,2],[7,3],[7,4],[7,5],[7,6]],green:[[1,7],[2,7],[3,7],[4,7],[5,7],[6,7]],yellow:[[7,13],[7,12],[7,11],[7,10],[7,9],[7,8]],blue:[[13,7],[12,7],[11,7],[10,7],[9,7],[8,7]]},
                START_POSITIONS: { red: 0, green: 13, yellow: 26, blue: 39 },
                HOME_SPOTS: {red:[[1,1],[1,4],[4,1],[4,4]],green:[[1,10],[1,13],[4,10],[4,13]],yellow:[[10,10],[10,13],[13,10],[13,13]],blue:[[10,1],[10,4],[13,1],[13,4]]}
            };
            
            // --- Game State Variables ---
            let gameState = {};
            let menuState = { numPlayers: 1, playerSelections: {} };
            let pawnElements = {};
            let cachedCellSize = 0;
            const sleep = ms => new Promise(res => setTimeout(res, ms));

            // --- Menu Logic (No changes needed here) ---
            function setupMenu() {
                mainMenu.style.display = 'flex';
                gameContainer.style.display = 'none';
                updateColorSelectors(menuState.numPlayers);
                playerCountSelector.addEventListener('change', (e) => {
                    menuState.numPlayers = parseInt(e.target.value);
                    menuState.playerSelections = {};
                    updateColorSelectors(menuState.numPlayers);
                    checkStartButtonState();
                });
                startGameBtn.addEventListener('click', () => {
                    if (startGameBtn.disabled) return;
                    mainMenu.style.display = 'none';
                    gameContainer.style.display = 'flex';
                    // --- OPTIMIZATION: Calculate cell size once the board is visible to avoid layout issues.
                    // This prevents reading from the DOM every time we need this value.
                    cachedCellSize = board.clientWidth / 15;
                    const playerTypes = {};
                    const humanColors = Object.values(menuState.playerSelections);
                    PLAYER_ORDER.forEach(color => {
                        playerTypes[color] = humanColors.includes(color) ? 'human' : 'ai';
                    });
                    initGame(playerTypes);
                });
            }
            function updateColorSelectors(num) {
                playerColorSelectorsContainer.innerHTML = '';
                for (let i = 1; i <= num; i++) {
                    const selectorId = `player${i}`;
                    playerColorSelectorsContainer.innerHTML += `
                        <div class="player-selector">
                            <span>Player ${i}:</span>
                            <div class="color-options" data-player-id="${selectorId}">
                                ${PLAYER_ORDER.map(color => `<div class="color-choice ${color}" data-color="${color}"></div>`).join('')}
                            </div>
                        </div>`;
                }
                updateSelectedColorsUI();
                addColorChoiceListeners();
            }
            function addColorChoiceListeners() {
                document.querySelectorAll('.color-choice').forEach(choice => {
                    choice.addEventListener('click', (e) => {
                        const color = e.target.dataset.color;
                        const playerId = e.target.parentElement.dataset.playerId;
                        if (Object.values(menuState.playerSelections).includes(color) && menuState.playerSelections[playerId] !== color) return;
                        if (menuState.playerSelections[playerId] === color) delete menuState.playerSelections[playerId];
                        else menuState.playerSelections[playerId] = color;
                        updateSelectedColorsUI();
                        checkStartButtonState();
                    });
                });
            }
            function updateSelectedColorsUI() {
                const takenColors = Object.values(menuState.playerSelections);
                document.querySelectorAll('.color-choice').forEach(choice => {
                    const color = choice.dataset.color;
                    const playerId = choice.parentElement.dataset.playerId;
                    choice.classList.remove('selected', 'taken');
                    if (menuState.playerSelections[playerId] === color) choice.classList.add('selected');
                    else if (takenColors.includes(color)) choice.classList.add('taken');
                });
            }
            function checkStartButtonState() {
                startGameBtn.disabled = Object.keys(menuState.playerSelections).length !== menuState.numPlayers;
            }

            // --- Game Initialization ---
            function initGame(playerTypes) {
                createBoardVisuals();
                gameState = {
                    playerTypes, currentPlayerIndex: -1, diceValue: null, diceRolled: false,
                    consecutiveSixes: 0, isAnimating: false, pawns: {},
                    boardState: {}, gameWon: false
                };
                // --- OPTIMIZATION: Clear previous pawn elements from DOM and memory cache
                document.querySelectorAll('.pawn').forEach(p => p.remove());
                pawnElements = {};

                for (const color of PLAYER_ORDER) {
                    for (let i = 0; i < 4; i++) {
                        const pawnId = `${color}-pawn-${i}`;
                        gameState.pawns[pawnId] = { id: pawnId, color: color, position: -1, isFinished: false };
                        
                        const pawnEl = document.createElement('div');
                        pawnEl.className = `pawn ${color}`;
                        pawnEl.id = pawnId;
                        pawnEl.innerText = i + 1;
                        pawnEl.addEventListener('click', () => handlePawnClick(pawnId));
                        board.appendChild(pawnEl);
                        pawnElements[pawnId] = pawnEl;

                        placePawn(pawnId, true);
                    }
                }
                diceEl.addEventListener('click', handleHumanRoll);
                switchPlayer();
            }

            // --- Visuals and Board Setup ---
            function createBoardVisuals() {
                board.innerHTML = '';
                const allCells = {};
                for (let r = 0; r < 15; r++) { for (let c = 0; c < 15; c++) {
                    const cell = document.createElement('div');
                    cell.className = `cell`;
                    board.appendChild(cell);
                    allCells[`${r}-${c}`] = cell;
                }}
                const homeBaseAreas = {
                    red:    { top: 0, left: 0, class: 'red-home-base' },
                    green:  { top: 0, left: 9, class: 'green-home-base' },
                    yellow: { top: 9, left: 9, class: 'yellow-home-base' },
                    blue:   { top: 9, left: 0, class: 'blue-home-base' }
                };
                for (const color in homeBaseAreas) {
                    const area = homeBaseAreas[color];
                    const homeBaseEl = document.createElement('div');
                    homeBaseEl.className = `home-base ${area.class}`;
                    homeBaseEl.style.top = `calc(var(--cell-size) * ${area.top})`;
                    homeBaseEl.style.left = `calc(var(--cell-size) * ${area.left})`;
                    for (let i = 0; i < 4; i++) {
                        const square = document.createElement('div');
                        square.className = 'home-base-square';
                        square.innerHTML = '<div class="home-spot"></div>';
                        homeBaseEl.appendChild(square);
                    }
                    board.appendChild(homeBaseEl);
                }
                PATH_DATA.PATH_COORDS.forEach(([r,c]) => allCells[`${r}-${c}`].classList.add('path'));
                Object.values(PATH_DATA.FINISH_PATH_COORDS).flat().forEach(([r,c]) => allCells[`${r}-${c}`].classList.add('path'));
                Object.entries(PATH_DATA.START_POSITIONS).forEach(([color, index]) => {
                    const [r,c] = PATH_DATA.PATH_COORDS[index];
                    allCells[`${r}-${c}`].classList.add('start', color);
                });
                Object.entries(PATH_DATA.FINISH_PATH_COORDS).forEach(([color, coords]) => coords.forEach(([r,c]) => allCells[`${r}-${c}`].classList.add('finish-path', color)));
            }

            // --- State Update and Rendering ---
            function updateBoardState(pawnId, oldPos, newPos) {
                const pawn = gameState.pawns[pawnId];
                const oldGlobal = getGlobalPathIndex(pawn.color, oldPos);
                const newGlobal = getGlobalPathIndex(pawn.color, newPos);

                if (oldGlobal !== null && gameState.boardState[oldGlobal]) {
                    gameState.boardState[oldGlobal] = gameState.boardState[oldGlobal].filter(id => id !== pawnId);
                    if (gameState.boardState[oldGlobal].length === 0) delete gameState.boardState[oldGlobal];
                }
                if (newGlobal !== null) {
                    if (!gameState.boardState[newGlobal]) gameState.boardState[newGlobal] = [];
                    // Ensure no duplicates
                    if (!gameState.boardState[newGlobal].includes(pawnId)) {
                        gameState.boardState[newGlobal].push(pawnId);
                    }
                }
            }
            
            function placePawn(pawnId, noTransition = false, positionOverride = null) {
                const pawnEl = pawnElements[pawnId];
                if (noTransition) pawnEl.style.transition = 'none';

                const [x, y] = getPawnTranslate(pawnId, positionOverride);
                const transformString = `translate(${x}px, ${y}px)`;
                
                pawnEl.style.transform = transformString;
                pawnEl.style.setProperty('--pawn-transform', transformString);

                if (noTransition) {
                    pawnEl.offsetHeight; // force paint
                    pawnEl.style.transition = '';
                }
            }

            // --- OPTIMIZATION: New function to update only pawns on a specific square.
            // This avoids looping through all 16 pawns when only a few need repositioning for stacking.
            function updateStackingForSquare(globalIndex) {
                if (globalIndex === null || !gameState.boardState[globalIndex]) return;

                const pawnsOnSquare = gameState.boardState[globalIndex];
                pawnsOnSquare.forEach(pawnId => {
                    placePawn(pawnId);
                });
            }

            function getPawnTranslate(pawnId, positionOverride = null) {
                const { color, isFinished } = gameState.pawns[pawnId];
                const position = positionOverride ?? gameState.pawns[pawnId].position;
                const pawnSize = cachedCellSize * 0.7;
                const centerOffset = (cachedCellSize - pawnSize) / 2;

                if (position === -1) { // In home base
                    const homeIndex = parseInt(pawnId.slice(-1));
                    const [row, col] = PATH_DATA.HOME_SPOTS[color][homeIndex];
                    return [col * cachedCellSize + centerOffset, row * cachedCellSize + centerOffset];
                }
            
                if (isFinished) { // Center of the board
                    return [7 * cachedCellSize + centerOffset, 7 * cachedCellSize + centerOffset];
                }

                let coords;
                if (position >= PATH_LENGTH) { // On finish path
                    const finishIndex = position - PATH_LENGTH;
                    coords = PATH_DATA.FINISH_PATH_COORDS[color][finishIndex];
                } else { // On main path
                    const pathIndex = getGlobalPathIndex(color, position);
                    coords = PATH_DATA.PATH_COORDS[pathIndex];
                }
                
                if (!coords) {
                    console.error(`Invalid coordinates for pawn ${pawnId} at position ${position}`);
                    return [0, 0];
                }

                // Stacking logic
                let offset = 0;
                const globalIndex = getGlobalPathIndex(color, position);
                // During mid-animation hops (positionOverride is not null), we don't apply stacking offset.
                // Stacking is only applied based on the final, authoritative board state.
                if (positionOverride === null && globalIndex !== null) {
                    const pawnsOnSquare = gameState.boardState[globalIndex] || [];
                    const stackIndex = pawnsOnSquare.indexOf(pawnId);
                    if (stackIndex > 0) { // Only offset if not the first pawn
                       offset = (pawnSize * 0.15) * stackIndex;
                    }
                }
                
                return [coords[1] * cachedCellSize + centerOffset + offset, coords[0] * cachedCellSize + centerOffset + offset];
            }

            const getGlobalPathIndex = (color, position) => {
                if(position === null || position < 0 || position >= PATH_LENGTH) return null;
                return (PATH_DATA.START_POSITIONS[color] + position) % PATH_LENGTH;
            }

            // --- Core Game Loop & Player Actions ---
            async function handleHumanRoll() {
                if (gameState.isAnimating || gameState.diceRolled) return;
                await processRoll();
            }
            
            async function processRoll() {
                await rollDice();

                if (gameState.consecutiveSixes === 3) {
                    updateStatus(`Rolled 3 sixes! Turn forfeited.`);
                    await sleep(1500);
                    endTurn(false);
                    return;
                }

                const movablePawns = findMovablePawns();
                
                if (movablePawns.length > 0) {
                    const currentPlayer = PLAYER_ORDER[gameState.currentPlayerIndex];
                    if (gameState.playerTypes[currentPlayer] === 'human') {
                        movablePawns.forEach(pawnId => pawnElements[pawnId].classList.add('movable'));
                    } else {
                        await sleep(500);
                        const bestPawnId = aiChooseBestMove(movablePawns);
                        await makeMove(bestPawnId);
                    }
                } else {
                    updateStatus(statusEl.innerHTML + " No possible moves.");
                    gameState.isAnimating = true;
                    await sleep(1200);
                    endTurn(gameState.diceValue === 6);
                }
            }

            async function handlePawnClick(pawnId) {
                const pawnEl = pawnElements[pawnId];
                const currentPlayer = PLAYER_ORDER[gameState.currentPlayerIndex];
                if (gameState.isAnimating || gameState.playerTypes[currentPlayer] === 'ai' || !pawnEl.classList.contains('movable')) return;
                
                document.querySelectorAll('.movable').forEach(el => el.classList.remove('movable'));
                await makeMove(pawnId);
            }
            
            async function makeMove(pawnId) {
                gameState.isAnimating = true;
                const pawn = gameState.pawns[pawnId];
                const oldPosition = pawn.position;
                const oldGlobalIndex = getGlobalPathIndex(pawn.color, oldPosition);

                await movePawnWithAnimation(pawnId);
                
                const newGlobalIndex = getGlobalPathIndex(pawn.color, pawn.position);
                updateBoardState(pawnId, oldPosition, pawn.position);

                // --- OPTIMIZATION: Only update stacking on the squares that were affected.
                if (oldGlobalIndex !== null) updateStackingForSquare(oldGlobalIndex);
                if (newGlobalIndex !== null) updateStackingForSquare(newGlobalIndex);

                const captureInfo = checkForCapture(pawn);
                if (captureInfo.captured) {
                    // Update stacking on the square where the captured pawn was returned to home.
                    updateStackingForSquare(captureInfo.victimGlobalIndex);
                }
                
                checkForWin();

                await endTurn(gameState.diceValue === 6 || captureInfo.captured);
            }

            async function rollDice() {
                diceEl.classList.add('rolling');
                gameState.diceRolled = true;
                gameState.isAnimating = true;
                
                const rollDuration = 500;
                const numberFlipper = setInterval(() => { diceEl.innerText = Math.floor(Math.random() * 6) + 1; }, 60);

                await sleep(rollDuration);
                clearInterval(numberFlipper);
                
                gameState.diceValue = Math.floor(Math.random() * 6) + 1;
                gameState.consecutiveSixes = (gameState.diceValue === 6) ? gameState.consecutiveSixes + 1 : 0;
                
                diceEl.innerText = gameState.diceValue;
                diceEl.classList.remove('rolling', 'active');
                updateStatus();
                await sleep(200);
                gameState.isAnimating = false;
            }

            function findMovablePawns() {
                const currentPlayer = PLAYER_ORDER[gameState.currentPlayerIndex];
                const dice = gameState.diceValue;

                return Object.values(gameState.pawns).filter(pawn => {
                    if (pawn.color !== currentPlayer || pawn.isFinished) return false;
                    if (pawn.position === -1) return dice === 6;
                    
                    const newPos = pawn.position + dice;
                    return newPos <= FINAL_SQUARE_POSITION;
                }).map(pawn => pawn.id);
            }

            async function movePawnWithAnimation(pawnId) {
                const pawn = gameState.pawns[pawnId];
                const pawnEl = pawnElements[pawnId];
                const startPos = pawn.position;
                const dice = gameState.diceValue;
                const hopDelay = 150; // JS delay should match CSS transition duration

                // Sound playback logic
                const playHopSound = () => {
                    if (hopSound.readyState >= 2) { // HAVE_CURRENT_DATA
                       hopSound.currentTime = 0; 
                       hopSound.play();
                    }
                }

                if (startPos === -1 && dice === 6) {
                    pawn.position = 0;
                    placePawn(pawnId, false, 0); // Use override to place at start
                    await sleep(50);
                    pawnEl.classList.add('hopping');
                    playHopSound();
                    await sleep(hopDelay + 50);
                    pawnEl.classList.remove('hopping');
                } else {
                    for (let i = 1; i <= dice; i++) {
                        const tempVisualPosition = startPos + i;
                        
                        // Use positionOverride so stacking isn't calculated mid-hop
                        placePawn(pawnId, false, tempVisualPosition);
                        await sleep(10); // allow paint
                        
                        pawnEl.classList.add('hopping');
                        playHopSound();
                        
                        await sleep(tempVisualPosition >= PATH_LENGTH ? hopDelay + 50 : hopDelay);
                        pawnEl.classList.remove('hopping');
                    }
                    pawn.position = startPos + dice;
                }

                if (pawn.position === FINAL_SQUARE_POSITION) {
                    pawn.isFinished = true;
                }

                // Final placement call without override to apply correct stacking
                placePawn(pawnId);
                await sleep(100);
            }

            function checkForCapture(movedPawn) {
                const movedGlobalIndex = getGlobalPathIndex(movedPawn.color, movedPawn.position);
                
                if (movedPawn.isFinished || movedPawn.position < 0 || movedPawn.position >= PATH_LENGTH) return { captured: false };
                
                const isSafeSquare = Object.values(PATH_DATA.START_POSITIONS).includes(movedGlobalIndex);
                if (isSafeSquare) return { captured: false };
                
                const victims = (gameState.boardState[movedGlobalIndex] || []).filter(id => 
                    gameState.pawns[id].color !== movedPawn.color
                );

                if (victims.length === 0) return { captured: false };

                let victimGlobalIndex = -1; // To return for targeted stacking update
                victims.forEach(victimId => {
                    const victimPawn = gameState.pawns[victimId];
                    updateStatus(`${movedPawn.color.toUpperCase()} captured ${victimPawn.color.toUpperCase()}'s pawn!`);
                    
                    const oldPos = victimPawn.position;
                    victimGlobalIndex = getGlobalPathIndex(victimPawn.color, oldPos); // Store this before changing state
                    
                    victimPawn.position = -1;
                    updateBoardState(victimId, oldPos, -1);
                    placePawn(victimId);
                });
                return { captured: true, victimGlobalIndex: victimGlobalIndex };
            }
            
            function checkForWin() {
                const currentPlayer = PLAYER_ORDER[gameState.currentPlayerIndex];
                const allFinished = Object.values(gameState.pawns).filter(p => p.color === currentPlayer).every(p => p.isFinished);
                if (allFinished) {
                    statusEl.innerHTML = `<h2 style="color:${PLAYERS[currentPlayer].color}; text-shadow: 1px 1px 5px black;">${currentPlayer.toUpperCase()} WINS!</h2>`;
                    diceEl.removeEventListener('click', handleHumanRoll);
                    diceEl.classList.remove('active');
                    diceEl.style.cursor = 'default';
                    gameState.gameWon = true;
                }
            }

            async function endTurn(getsExtraRoll) {
                if (gameState.gameWon) return;
                if (getsExtraRoll) {
                    gameState.diceRolled = false;
                    gameState.isAnimating = false;
                    const currentPlayer = PLAYER_ORDER[gameState.currentPlayerIndex];
                    let message = (gameState.diceValue === 6) ? `Rolled a 6!` : `Bonus turn for the capture!`;
                    updateStatus(`${message} <strong style="color:${PLAYERS[currentPlayer].color}">${currentPlayer.toUpperCase()}</strong>, roll again.`);
                    if (gameState.playerTypes[currentPlayer] === 'ai') {
                        diceEl.style.pointerEvents = 'none';
                        await sleep(1000);
                        executeAITurn();
                    } else {
                        diceEl.style.pointerEvents = 'auto';
                        diceEl.classList.add("active");
                    }
                } else {
                    await sleep(500);
                    switchPlayer();
                }
            }
            function switchPlayer() {
                if (gameState.gameWon) return;
                gameState.isAnimating = false; gameState.diceRolled = false;
                gameState.diceValue = null; gameState.consecutiveSixes = 0;
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % PLAYER_ORDER.length;
                const currentPlayer = PLAYER_ORDER[gameState.currentPlayerIndex];
                updateStatus();
                if (gameState.playerTypes[currentPlayer] === 'ai') {
                    diceEl.style.pointerEvents = 'none';
                    setTimeout(executeAITurn, 1000);
                } else {
                    diceEl.style.pointerEvents = 'auto';
                }
            }
            function updateStatus(message = "") {
                const currentPlayer = PLAYER_ORDER[gameState.currentPlayerIndex];
                if (!currentPlayer) return;
                const playerInfo = PLAYERS[currentPlayer];
                const playerType = gameState.playerTypes[currentPlayer];
                statusEl.innerHTML = message ? message : 
                    playerType === 'ai' 
                        ? `<strong style="color:${playerInfo.color}">${currentPlayer.toUpperCase()} (AI)</strong> is thinking...`
                        : `It's <strong style="color:${playerInfo.color}">${currentPlayer.toUpperCase()}</strong>'s turn. Roll the dice!`;
                diceEl.innerText = gameState.diceValue || "?";
                diceEl.style.setProperty("--current-player-color", playerInfo.color);
                root.style.setProperty("--current-player-color-glow", playerInfo.glow);
                if (!gameState.diceRolled && playerType === 'human' && !gameState.gameWon) {
                    diceEl.classList.add("active");
                } else {
                    diceEl.classList.remove("active");
                }
            }
            async function executeAITurn() {
                if (gameState.gameWon || gameState.isAnimating) return;
                gameState.isAnimating = true;
                updateStatus();
                await sleep(800);
                await processRoll();
                gameState.isAnimating = false;
            }
            function aiChooseBestMove(movablePawns) {
                const dice = gameState.diceValue;
                let bestMove = {pawnId: null, score: -Infinity};
                for(const pawnId of movablePawns) {
                    const pawn = gameState.pawns[pawnId];
                    const newPos = (pawn.position === -1) ? 0 : pawn.position + dice;
                    let score = 0;
                    if (newPos === FINAL_SQUARE_POSITION) score += 1000;
                    if (pawn.position === -1 && dice === 6) score += 50;
                    score += newPos;
                    if (newPos < PATH_LENGTH) {
                        const newGlobalIndex = getGlobalPathIndex(pawn.color, newPos);
                        const isSafe = Object.values(PATH_DATA.START_POSITIONS).includes(newGlobalIndex);
                        if (!isSafe) {
                            const opponentOnSquare = Object.values(gameState.pawns).some(op => op.color !== pawn.color && !op.isFinished && getGlobalPathIndex(op.color, op.position) === newGlobalIndex);
                            if (opponentOnSquare) score += 75;
                        } else {
                            score += 20;
                        }
                    }
                    if(score > bestMove.score) bestMove = { pawnId, score };
                }
                return bestMove.pawnId || movablePawns[Math.floor(Math.random() * movablePawns.length)];
            }
            
            setupMenu();
        });
    </script>
</body>
</html>

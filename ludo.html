<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ludo - Classic Gameplay</title>
    <style>
        :root {
            /* Responsive board size: min 320px, preferred 90% of viewport, max 700px */
            --board-size: clamp(320px, 90vmin, 700px);
            --cell-size: calc(var(--board-size) / 15);
            --pawn-size: calc(var(--cell-size) * 0.7);
            --hop-duration: 0.2s;
            --hop-interval: 0.25s;
            --dice-roll-duration: 1s;

            --red-color: #d63031;
            --green-color: #00b894;
            --yellow-color: #fdd835;
            --blue-color: #0984e3;

            --red-home: #e17055;
            --green-home: #55efc4;
            --yellow-home: #ffeaa7;
            --blue-home: #74b9ff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2c3e50;
            background-image: radial-gradient(circle, #34495e, #2c3e50);
            color: #fff;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        #game-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            align-items: flex-start; /* Align to top */
        }

        #board-wrapper {
            position: relative;
        }

        #board {
            width: var(--board-size);
            height: var(--board-size);
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            border: 10px solid #634832;
            border-radius: 15px;
            background-color: #c89666;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 80 80"><rect width="80" height="80" fill="%23c89666"/><path d="M 0,10 C 20,0, 40,0, 60,10 C 80,20, 80,30, 80,40 C 70,60, 60,80, 40,80 C 20,80, 0,60, 0,40z" fill-opacity="0.1" fill="%235a3a22"/><path d="M 80,10 C 60,0, 40,0, 20,10 C 0,20, 0,30, 0,40 C 10,60, 20,80, 40,80 C 60,80, 80,60, 80,40z" fill-opacity="0.1" fill="%235a3a22"/></svg>');
            box-shadow: 0 15px 30px rgba(0,0,0,0.5), inset 0 0 10px rgba(0,0,0,0.3);
            position: relative;
        }

        #board::before {
            content: '';
            position: absolute;
            top: calc(var(--cell-size) * 6); left: calc(var(--cell-size) * 6);
            width: calc(var(--cell-size) * 3); height: calc(var(--cell-size) * 3);
            background:
                linear-gradient(45deg, var(--green-color) 50%, transparent 50.5%),
                linear-gradient(135deg, var(--red-color) 50%, transparent 50.5%),
                linear-gradient(225deg, var(--blue-color) 50%, transparent 50.5%),
                linear-gradient(315deg, var(--yellow-color) 50%, transparent 50.5%);
            z-index: 1;
            border-radius: 10%;
        }

        #turn-indicator {
            position: absolute;
            z-index: 5;
            border: 5px solid var(--current-player-color);
            box-shadow: 0 0 20px 5px var(--current-player-color-glow);
            border-radius: 10px;
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .cell { box-sizing: border-box; position: relative; }
        .cell.target-highlight::after {
            content: '';
            position: absolute; top: 10%; left: 10%;
            width: 80%; height: 80%;
            border-radius: 50%;
            background-color: var(--current-player-color);
            opacity: 0.5;
            animation: pulse-glow 1.5s infinite;
        }


        .home-base { border: 3px solid #2c3e50; box-shadow: inset 0 0 10px rgba(0,0,0,0.2); }
        .red-home-base { background-color: var(--red-home); }
        .green-home-base { background-color: var(--green-home); }
        .yellow-home-base { background-color: var(--yellow-home); }
        .blue-home-base { background-color: var(--blue-home); }
        .home-spot { border: 2px dashed rgba(0,0,0,0.2); border-radius: 50%; margin: 15%; background-color: rgba(255,255,255,0.2); }

        .path { background-color: #f5eadd; box-shadow: inset 0 0 8px rgba(0,0,0,0.25); }
        .start {
            background-size: 60%; background-position: center; background-repeat: no-repeat;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="white" d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>');
        }
        .start.red { background-color: var(--red-color); }
        .start.green { background-color: var(--green-color); }
        .start.yellow { background-color: var(--yellow-color); }
        .start.blue { background-color: var(--blue-color); }

        .finish-path.red { background-color: var(--red-color); box-shadow: inset 0 0 8px rgba(0,0,0,0.4); }
        .finish-path.green { background-color: var(--green-color); box-shadow: inset 0 0 8px rgba(0,0,0,0.4); }
        .finish-path.yellow { background-color: var(--yellow-color); box-shadow: inset 0 0 8px rgba(0,0,0,0.4); }
        .finish-path.blue { background-color: var(--blue-color); box-shadow: inset 0 0 8px rgba(0,0,0,0.4); }

        .pawn {
            position: absolute; z-index: 10;
            width: var(--pawn-size); height: var(--pawn-size);
            border-radius: 50%; border: 2px solid rgba(255,255,255,0.8);
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            transition: top var(--hop-duration) cubic-bezier(0.34, 1.56, 0.64, 1),
                        left var(--hop-duration) cubic-bezier(0.34, 1.56, 0.64, 1),
                        transform var(--hop-duration) ease-in-out;
            display: flex; justify-content: center; align-items: center;
            font-size: calc(var(--pawn-size) * 0.6); font-weight: bold;
            color: white; text-shadow: 1px 1px 2px black;
        }
        .pawn::after {
            content: attr(data-stack-size);
            position: absolute; top: -5px; right: -5px;
            background-color: rgba(0,0,0,0.7);
            color: white; border-radius: 50%;
            width: 18px; height: 18px;
            font-size: 12px;
            display: none; justify-content: center; align-items: center;
            border: 1px solid white;
        }
        .pawn[data-stack-size]::after { display: flex; }


        .pawn.hopping {
            transform: translateY(calc(var(--pawn-size) * -0.5)) scale(1.1);
            box-shadow: 0 10px 15px rgba(0,0,0,0.4);
        }

        .pawn.red { background: radial-gradient(circle at 30% 30%, #e55039, #c0392b); }
        .pawn.green { background: radial-gradient(circle at 30% 30%, #1dd1a1, #00b894); }
        .pawn.yellow { background: radial-gradient(circle at 30% 30%, #feca57, #f39c12); }
        .pawn.blue { background: radial-gradient(circle at 30% 30%, #48dbfb, #0984e3); }

        .pawn.movable {
            cursor: pointer;
            animation: pulse-glow 1.5s infinite;
        }
        .pawn.movable:hover {
            transform: scale(1.15);
        }

        #game-info {
            display: flex; flex-direction: column; align-items: center;
            background-color: rgba(44, 62, 80, 0.8); padding: 20px; border-radius: 15px;
            width: 280px; border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px); box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            position: relative;
        }

        #utility-buttons { position: absolute; top: 10px; right: 10px; display: flex; gap: 5px; }
        #utility-buttons button {
            width: 30px; height: 30px; border-radius: 50%; border: 1px solid #7f8c8d;
            background-color: rgba(0,0,0,0.3); color: white; font-size: 1.2em;
            cursor: pointer; transition: all 0.2s; display: flex; justify-content: center; align-items: center;
        }
        #utility-buttons button:hover { background-color: rgba(255,255,255,0.2); transform: scale(1.1); }


        #status { font-size: 1.2em; text-align: center; min-height: 50px; margin-bottom: 20px; margin-top: 20px; }
        #dice-container {
            perspective: 1000px;
            margin-bottom: 20px;
        }
        #dice {
            width: 80px; height: 80px; position: relative;
            transform-style: preserve-3d;
            /* Transition for landing on face after roll */
            transition: transform 0.5s cubic-bezier(0.25, 1, 0.5, 1);
            cursor: pointer;
        }
        #dice.active { animation: jiggle 0.5s; }
        #dice.rolling {
            animation: spin-dice var(--dice-roll-duration) cubic-bezier(0.3, 0.7, 0.4, 1.0);
            transition: none; /* Disable landing transition during spin */
        }

        .dice-face {
            position: absolute; width: 100%; height: 100%;
            background-color: #fff; border-radius: 10px; border: 2px solid #ccc;
            display: grid; padding: 8px; box-sizing: border-box;
            grid-template-areas: "a . c" ". e ." "d . b";
        }
        .dice-pip {
            width: 16px; height: 16px;
            background-color: #333;
            border-radius: 50%;
            align-self: center; justify-self: center;
        }
        .dice-pip:nth-child(1) { grid-area: a; }
        .dice-pip:nth-child(2) { grid-area: b; }
        .dice-pip:nth-child(3) { grid-area: c; }
        .dice-pip:nth-child(4) { grid-area: d; }
        .dice-pip:nth-child(5) { grid-area: e; }
        .dice-pip:nth-child(6) { grid-area: f; } /* For face 6, first 4 pips use a,b,c,d */
        
        .face-1 { transform: rotateY(0deg) translateZ(40px); grid-template-areas: ". . ." ". e ." ". . ."; }
        .face-2 { transform: rotateY(-90deg) translateZ(40px); grid-template-areas: "a . ." ". . ." ". . b"; }
        .face-3 { transform: rotateY(90deg) translateZ(40px); grid-template-areas: "a . ." ". e ." ". . b"; }
        .face-4 { transform: rotateX(-90deg) translateZ(40px); grid-template-areas: "a . c" ". . ." "d . b"; }
        .face-5 { transform: rotateX(90deg) translateZ(40px); grid-template-areas: "a . c" ". e ." "d . b"; }
        .face-6 { transform: rotateY(180deg) translateZ(40px); grid-template-areas: "a . c" "f . g" "d . b"; } /* f and g are new grid areas for 6 */
        /* Correct pip placement for face 6 based on 6 pips */
        .face-6 .dice-pip:nth-child(1) { grid-area: a; }
        .face-6 .dice-pip:nth-child(2) { grid-area: c; }
        .face-6 .dice-pip:nth-child(3) { grid-area: f; } /* middle left */
        .face-6 .dice-pip:nth-child(4) { grid-area: g; } /* middle right */
        .face-6 .dice-pip:nth-child(5) { grid-area: d; }
        .face-6 .dice-pip:nth-child(6) { grid-area: b; }


        #pass-turn-btn { display: none; margin-top: 10px; }

        #game-log-container {
            width: 100%; margin-top: 15px;
            background-color: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;
        }
        #game-log-container h3 { margin: 0 0 10px 0; text-align: center; font-size: 1em; color: #bdc3c7;}
        #game-log {
            height: 100px; overflow-y: auto; font-size: 0.85em;
            padding-right: 5px;
        }
        #game-log p { margin: 0 0 5px; padding: 0; }
        #game-log p:last-child { margin-bottom: 0; }
        #game-log::-webkit-scrollbar { width: 5px; }
        #game-log::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 5px; }
        #game-log::-webkit-scrollbar-thumb { background: #7f8c8d; border-radius: 5px; }


        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center; backdrop-filter: blur(5px); }
        .modal-content {
            background-color: #34495e;
            color: #ecf0f1;
            margin: auto;
            padding: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 90%;
            max-width: 500px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
            animation: modal-fade-in 0.3s;
        }
        .modal-content h2 { margin-top: 0; color: #fff; }
        .modal-content button {
            padding: 12px 30px; font-size: 1.2em;
            background-color: #27ae60; color: white;
            border: none; border-radius: 8px;
            cursor: pointer; transition: background-color 0.3s;
        }
        .modal-content button:hover { background-color: #2ecc71; }

        #winner-modal .modal-content { max-width: 600px; }
        #winner-podium { display: flex; justify-content: center; align-items: flex-end; gap: 15px; margin: 30px 0; height: 200px; }
        .podium-stand {
            display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
            width: 120px; border-radius: 10px 10px 0 0;
            padding: 10px; color: white; font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .podium-stand .pawn { position: static; margin-bottom: 10px; }
        .podium-1 { background-color: #e67e22; height: 180px; font-size: 2em; }
        .podium-2 { background-color: #95a5a6; height: 140px; font-size: 1.5em; }
        .podium-3 { background-color: #e74c3c; height: 100px; font-size: 1.2em; }

        #main-menu { display: flex; }
        .menu-section { margin-bottom: 25px; }
        .menu-section h3 {
            margin-bottom: 15px;
            color: #bdc3c7;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 10px;
            font-weight: 300;
        }
        .player-count-selector {
            background-color: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 8px;
            display: inline-flex;
            gap: 5px;
        }
        .player-count-selector label {
            padding: 8px 15px;
            font-size: 1.1em;
            cursor: pointer;
            border-radius: 6px;
            transition: background-color 0.2s;
            position: relative;
        }
        .player-count-selector input { position: absolute; opacity: 0; width: 0; height: 0; }
        .player-count-selector input:checked + span { color: #3498db; font-weight: bold; }
        .player-count-selector label:hover { background-color: rgba(255,255,255,0.05); }

        .player-color-selectors { display: flex; flex-direction: column; gap: 15px; }
        .player-selector {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(0,0,0,0.25);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            transition: opacity 0.3s ease, max-height 0.4s ease, margin 0.4s ease, padding 0.4s ease, border-width 0.4s ease;
            overflow: hidden;
            padding: 15px;
            max-height: 100px;
        }
        .player-selector.hidden {
            opacity: 0;
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            margin-bottom: -15px; /* Counteract gap */
            border-width: 0;
        }

        .player-selector span { font-weight: bold; color: #fff; }
        .color-options { display: flex; gap: 10px; }
        .color-choice {
            width: 40px; height: 40px; border-radius: 50%;
            cursor: pointer; border: 4px solid transparent;
            transition: all 0.2s;
        }
        .color-choice.red { background-color: var(--red-color); }
        .color-choice.green { background-color: var(--green-color); }
        .color-choice.yellow { background-color: var(--yellow-color); }
        .color-choice.blue { background-color: var(--blue-color); }
        .color-choice:hover { transform: scale(1.1); }
        .color-choice.selected { border-color: #3498db; box-shadow: 0 0 10px #3498db; }
        .color-choice.taken { cursor: not-allowed; opacity: 0.3; transform: scale(0.9); }

        .game-button {
            padding: 12px 30px; font-size: 1.2em;
            background-color: #27ae60; color: white;
            border: none; border-radius: 8px;
            cursor: pointer; transition: background-color 0.3s;
        }
        .game-button:disabled { background-color: #95a5a6; cursor: not-allowed; }
        .game-button:not(:disabled):hover { background-color: #2ecc71; }


        @keyframes modal-fade-in { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        @keyframes pulse-glow {
            0%, 100% { transform: scale(1); box-shadow: 0 4px 8px rgba(0,0,0,0.5), 0 0 0 0px var(--current-player-color-glow); opacity: 1; }
            50% { transform: scale(1.1); box-shadow: 0 6px 12px rgba(0,0,0,0.4), 0 0 15px 5px var(--current-player-color-glow); opacity: 0.7; }
        }
        @keyframes spin-dice {
            0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg) translateZ(40px); }
            100% { transform: rotateX(720deg) rotateY(1080deg) rotateZ(360deg) translateZ(40px); }
        }
        @keyframes jiggle {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.05) rotate(-5deg); }
            75% { transform: scale(1.05) rotate(5deg); }
        }

        @media (max-width: 800px) {
            body { padding: 10px; }
            #game-container { flex-direction: column; gap: 20px; }
            #game-info { width: var(--board-size); max-width: 100%; }
            #game-info h1 { font-size: 1.5em; }
        }
    </style>
</head>
<body>
    <div id="main-menu" class="modal">
        <div class="modal-content">
            <h2>Welcome to Ludo!</h2>
            <div class="menu-section">
                <h3>How many human players?</h3>
                <div class="player-count-selector">
                    <label><input type="radio" name="player-count" value="1" checked> <span>1</span></label>
                    <label><input type="radio" name="player-count" value="2"> <span>2</span></label>
                    <label><input type="radio" name="player-count" value="3"> <span>3</span></label>
                    <label><input type="radio" name="player-count" value="4"> <span>4</span></label>
                </div>
            </div>
            <div class="menu-section">
                <h3>Choose your colors:</h3>
                <div id="player-color-selectors" class="player-color-selectors"></div>
            </div>
            <button id="start-game-btn" class="game-button" disabled>Start Game</button>
        </div>
    </div>

    <div id="rules-modal" class="modal">
        <div class="modal-content" style="text-align: left;">
            <h2>Game Rules</h2>
            <ul>
                <li><strong>Objective:</strong> Be the first to get all 4 of your pawns from your home base to the center triangle.</li>
                <li><strong>Getting Out:</strong> You must roll a 6 to move a pawn from your home base to your starting square.</li>
                <li><strong>Rolling a 6:</strong> Rolling a 6 gives you an extra turn.</li>
                <li><strong>Capture:</strong> If you land on a square occupied by an opponent's pawn, their pawn is sent back to its home base. Safe squares (colored start squares) are exempt.</li>
                <li><strong>Stacking:</strong> Landing on a square with your own pawn stacks them. Stacks move together and are immune to capture by single enemy pawns. A stack can only be captured by an enemy stack of equal or greater size.</li>
                <li><strong>Blockades:</strong> A stack of 2 or more of your pawns on a regular path square creates a blockade that no pawn (even your own) can pass.</li>
            </ul>
            <button id="close-rules-btn" class="game-button" style="display: block; margin: 20px auto 0;">Got it!</button>
        </div>
    </div>

    <div id="winner-modal" class="modal">
        <div class="modal-content">
            <h2>Game Over!</h2>
            <div id="winner-podium"></div>
            <button id="play-again-btn" class="game-button">Play Again</button>
        </div>
    </div>

    <div id="game-container" style="display: none;">
        <div id="board-wrapper">
            <div id="board"></div>
            <div id="turn-indicator"></div>
        </div>
        <div id="game-info">
            <div id="utility-buttons">
                <button id="rules-btn">?</button>
                <button id="sound-btn">🔊</button>
            </div>
            <h1>Ludo</h1>
            <div id="status">Welcome! Roll the dice to start.</div>
            <div id="dice-container">
                 <div id="dice"></div>
            </div>
            <button id="pass-turn-btn" class="game-button" style="background-color: #f39c12;">Pass Turn</button>
            <div id="game-log-container">
                <h3>Game Log</h3>
                <div id="game-log"></div>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- Game Elements ---
    const gameContainer = document.getElementById('game-container');
    const board = document.getElementById('board');
    const turnIndicator = document.getElementById('turn-indicator');
    const diceEl = document.getElementById('dice');
    const statusEl = document.getElementById('status');
    const gameLogEl = document.getElementById('game-log');
    const passTurnBtn = document.getElementById('pass-turn-btn');
    const root = document.documentElement;
    const hopSound = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');
    hopSound.volume = 0.4;

    // --- Menu & Modal Elements ---
    const mainMenu = document.getElementById('main-menu');
    const playerCountSelector = document.querySelector('.player-count-selector');
    const playerColorSelectorsContainer = document.getElementById('player-color-selectors');
    const startGameBtn = document.getElementById('start-game-btn');
    const rulesModal = document.getElementById('rules-modal');
    const closeRulesBtn = document.getElementById('close-rules-btn');
    const rulesBtn = document.getElementById('rules-btn');
    const soundBtn = document.getElementById('sound-btn');
    const winnerModal = document.getElementById('winner-modal');
    const winnerPodiumEl = document.getElementById('winner-podium');
    const playAgainBtn = document.getElementById('play-again-btn');

    // --- Game Constants ---
    const PLAYERS = {
        red: { color: 'var(--red-color)', glow: 'rgba(214, 48, 49, 0.7)' },
        green: { color: 'var(--green-color)', glow: 'rgba(0, 184, 148, 0.7)' },
        yellow: { color: 'var(--yellow-color)', glow: 'rgba(253, 216, 53, 0.7)' },
        blue: { color: 'var(--blue-color)', glow: 'rgba(9, 132, 227, 0.7)' }
    };
    const PLAYER_ORDER = ['red', 'green', 'yellow', 'blue'];
    
    const PATH_DATA = {
        PATH_COORDS: [[6,1],[6,2],[6,3],[6,4],[6,5],[5,6],[4,6],[3,6],[2,6],[1,6],[0,6],[0,7],[0,8],[1,8],[2,8],[3,8],[4,8],[5,8],[6,9],[6,10],[6,11],[6,12],[6,13],[7,14],[8,14],[8,13],[8,12],[8,11],[8,10],[8,9],[9,8],[10,8],[11,8],[12,8],[13,8],[14,8],[14,7],[14,6],[13,6],[12,6],[11,6],[10,6],[9,6],[8,5],[8,4],[8,3],[8,2],[8,1],[7,0],[6,0]],
        FINISH_PATH_COORDS: {red:[[7,1],[7,2],[7,3],[7,4],[7,5],[7,6]],green:[[1,7],[2,7],[3,7],[4,7],[5,7],[6,7]],yellow:[[7,13],[7,12],[7,11],[7,10],[7,9],[7,8]],blue:[[13,7],[12,7],[11,7],[10,7],[9,7],[8,7]]},
        START_POSITIONS: { red: 0, green: 13, yellow: 26, blue: 39 },
        HOME_SPOTS: {red:[[1,1],[1,4],[4,1],[4,4]],green:[[1,10],[1,13],[4,10],[4,13]],yellow:[[10,10],[10,13],[13,10],[13,13]],blue:[[10,1],[10,4],[13,1],[13,4]]}
    };

    const MAIN_PATH_LOGICAL_LENGTH = PATH_DATA.PATH_COORDS.length; // Should be 51
    const FINISH_PATH_LENGTH = 6;
    const TOTAL_LOGICAL_PATH_LENGTH = MAIN_PATH_LOGICAL_LENGTH + FINISH_PATH_LENGTH;


    // --- Game State Variables ---
    let gameState = {};
    let menuState = { numPlayers: 1, playerSelections: {} };
    const sleep = ms => new Promise(res => setTimeout(res, ms));

    // --- Menu & Setup Logic ---
    function setupMenu() {
        mainMenu.style.display = 'flex';
        gameContainer.style.display = 'none';
        winnerModal.style.display = 'none';

        createColorSelectors();
        addColorChoiceListeners();
        updatePlayerSelectorVisibility(menuState.numPlayers);
        checkStartButtonState();

        playerCountSelector.addEventListener('change', (e) => {
            menuState.numPlayers = parseInt(e.target.value);
            updatePlayerSelectorVisibility(menuState.numPlayers);
            updateSelectedColorsUI();
            checkStartButtonState();
        });

        startGameBtn.addEventListener('click', async () => { // Made async
            if (startGameBtn.disabled) return;
            mainMenu.style.display = 'none';
            gameContainer.style.display = 'flex';
            
            const humanColors = Object.values(menuState.playerSelections);
            const aiColorsNeeded = menuState.numPlayers - humanColors.length; // This logic needs adjustment
            // It should be total selected players from menu vs human players chosen for color
            // Simpler: total active players selected in menu (numPlayers)
            // Colors chosen are for human players. Remaining are AI.
            
            const chosenHumanColors = Object.values(menuState.playerSelections);
            const activePlayerColors = [];
            const playerTypes = {};

            // Assign colors based on PLAYER_ORDER for active players
            let humanColorIndex = 0;
            for (let i = 0; i < menuState.numPlayers; i++) {
                const colorForThisSlot = PLAYER_ORDER[i]; // Take colors in fixed order for active slots
                activePlayerColors.push(colorForThisSlot);
                if (chosenHumanColors.includes(colorForThisSlot)) {
                    playerTypes[colorForThisSlot] = 'human';
                } else {
                    playerTypes[colorForThisSlot] = 'ai';
                }
            }
            // Ensure chosenHumanColors are actually part of the first numPlayers colors
            // The menu allows choosing any color for Player 1, Player 2 etc. up to numPlayers.
            // This needs to map to fixed game colors (Red, Green, Yellow, Blue)
            // Let's refine player/color assignment:
            // Player 1 in menu picks a color. That color becomes P1.
            // If numPlayers is 2, Player 2 picks another color.
            // The game will use specific colors (Red, Green, etc.).
            // The menu current setup implies Player 1 (human) *chooses* to be Red, Green, etc.
            
            // Corrected player setup based on menu choice:
            const gamePlayerColors = PLAYER_ORDER.slice(0, menuState.numPlayers); // These are the colors IN THE GAME (Red, Green, then Yellow, Blue if 3-4p)
            const finalPlayerTypes = {};
            gamePlayerColors.forEach(gameColor => {
                // Check if any human player in the menu selected this gameColor
                let isHuman = false;
                for (const playerId in menuState.playerSelections) { // playerId is "player1", "player2"
                    if (menuState.playerSelections[playerId] === gameColor) {
                        isHuman = true;
                        break;
                    }
                }
                finalPlayerTypes[gameColor] = isHuman ? 'human' : 'ai';
            });

            await initGame(finalPlayerTypes, menuState.numPlayers, gamePlayerColors); // await for initGame
        });

        rulesBtn.onclick = () => rulesModal.style.display = 'flex';
        closeRulesBtn.onclick = () => rulesModal.style.display = 'none';
        soundBtn.onclick = toggleSound;
        playAgainBtn.onclick = setupMenu;
        passTurnBtn.onclick = () => {
            passTurnBtn.style.display = 'none';
            switchPlayer();
        }
    }

    function createColorSelectors() {playerColorSelectorsContainer.innerHTML = '';for (let i = 1; i <= 4; i++) {playerColorSelectorsContainer.innerHTML += `<div id="player-${i}-selector" class="player-selector hidden"><span>Player ${i} (Human):</span><div class="color-options" data-player-id="player${i}">${PLAYER_ORDER.map(c => `<div class="color-choice ${c}" data-color="${c}"></div>`).join('')}</div></div>`;}}
    function updatePlayerSelectorVisibility(numHumanPlayers) {
        // Clear selections for players no longer active
        for (const playerId in menuState.playerSelections) {
            const playerNum = parseInt(playerId.replace('player', ''));
            if (playerNum > numHumanPlayers) {
                delete menuState.playerSelections[playerId];
            }
        }
        // Show/hide selectors
        for (let i = 1; i <= 4; i++) {
            const selector = document.getElementById(`player-${i}-selector`);
            if (i <= numHumanPlayers) { // num is number of HUMAN players
                selector.classList.remove('hidden');
            } else {
                selector.classList.add('hidden');
            }
        }
    }
    function addColorChoiceListeners() {document.querySelectorAll('.color-choice').forEach(choice => {choice.addEventListener('click', (e) => {const color = e.target.dataset.color;const playerId = e.target.parentElement.dataset.playerId;if (Object.values(menuState.playerSelections).includes(color) && menuState.playerSelections[playerId] !== color) {return;}if (menuState.playerSelections[playerId] === color) {delete menuState.playerSelections[playerId];} else {menuState.playerSelections[playerId] = color;}updateSelectedColorsUI();checkStartButtonState();});});}
    function updateSelectedColorsUI() {const takenColors = Object.values(menuState.playerSelections);document.querySelectorAll('.color-choice').forEach(choice => {const color = choice.dataset.color;const playerId = choice.parentElement.dataset.playerId;choice.classList.remove('selected', 'taken');if (menuState.playerSelections[playerId] === color) {choice.classList.add('selected');} else if (takenColors.includes(color)) {choice.classList.add('taken');}});}
    function checkStartButtonState() {
        // Start button enabled if number of human players selected matches the number of colors picked
        const numHumanPlayers = parseInt(document.querySelector('input[name="player-count"]:checked').value);
        startGameBtn.disabled = Object.keys(menuState.playerSelections).length !== numHumanPlayers;
    }


    // --- Game Initialization ---
    async function initGame(playerTypes, numGamePlayers, currentActivePlayers) { // playerTypes maps gameColor to 'human'/'ai'
        createBoardVisuals();
        createDiceVisuals();

        gameState = {
            playerTypes, // e.g. {red: 'human', green: 'ai'}
            numPlayers: numGamePlayers, // Total players in this game (e.g., 2, 3, or 4)
            activePlayers: currentActivePlayers, // Array of colors in play e.g. ['red', 'green']
            currentPlayerIndex: -1,
            diceValue: null,
            diceRolled: false,
            isAnimating: false,
            pawns: {},
            playersState: {},
            winners: [],
            gameWon: false,
            isSoundOn: true,
            gameLog: [],
        };
        
        gameState.activePlayers.forEach(color => {
            gameState.playersState[color] = { isTrapped: false };
            for (let i = 0; i < 4; i++) {
                const pawnId = `${color}-pawn-${i}`;
                gameState.pawns[pawnId] = { id: pawnId, color: color, position: -1, isFinished: false, stackSize: 1 };
            }
        });
        
        // Ensure board is rendered and dimensions are available
        await new Promise(resolve => requestAnimationFrame(resolve)); 

        renderAllPawns();
        renderDice(1); 
        
        addToLog('Game started. Good luck!');
        diceEl.addEventListener('click', handleHumanRoll);
        
        switchPlayer(); // This will set the first player and update turn indicator
    }

    // --- Visuals and Board Setup ---
    function createBoardVisuals() {
        board.innerHTML = '';
        for (let r = 0; r < 15; r++) {
            for (let c = 0; c < 15; c++) {
                const cell = document.createElement('div');
                cell.className = `cell`;
                cell.dataset.row = r;
                cell.dataset.col = c;

                if (r < 6 && c < 6) cell.classList.add('red-home-base', 'home-base');
                else if (r < 6 && c > 8) cell.classList.add('green-home-base', 'home-base');
                else if (r > 8 && c > 8) cell.classList.add('yellow-home-base', 'home-base');
                else if (r > 8 && c < 6) cell.classList.add('blue-home-base', 'home-base');
                
                board.appendChild(cell);
            }
        }
        const getCell = (r, c) => board.querySelector(`[data-row="${r}"][data-col="${c}"]`);
        PATH_DATA.PATH_COORDS.forEach(c => getCell(c[0],c[1]).classList.add('path'));
        Object.values(PATH_DATA.FINISH_PATH_COORDS).flat().forEach(c => getCell(c[0],c[1]).classList.add('path'));
        
        Object.entries(PATH_DATA.START_POSITIONS).forEach(([color, pathStartIndex]) => {
            const [r,c] = PATH_DATA.PATH_COORDS[pathStartIndex];
            getCell(r,c).classList.add('start', color);
        });

        Object.entries(PATH_DATA.FINISH_PATH_COORDS).forEach(([color, coords]) => coords.forEach(c => getCell(c[0],c[1]).classList.add('finish-path', color)));
        Object.values(PATH_DATA.HOME_SPOTS).flat().forEach(s => getCell(s[0],s[1]).innerHTML='<div class="home-spot"></div>');
    }

    function renderAllPawns() {
        document.querySelectorAll('.pawn').forEach(p => p.remove());
        if (!board.clientWidth) { // Guard against rendering if board not sized
            console.warn("Board not sized, delaying pawn rendering.");
            requestAnimationFrame(renderAllPawns);
            return;
        }
        for (const pawnId in gameState.pawns) {
            const pawn = gameState.pawns[pawnId];
            if (!gameState.activePlayers.includes(pawn.color)) continue; 
            
            const pawnEl = document.createElement('div');
            pawnEl.className = `pawn ${pawn.color}`;
            pawnEl.id = pawnId;
            const [top, left] = getPawnCoords(pawn);
            pawnEl.style.transition = 'none'; 
            pawnEl.style.top = `${top}px`;
            pawnEl.style.left = `${left}px`;
            pawnEl.offsetHeight; 
            pawnEl.style.transition = ''; 
            pawnEl.addEventListener('click', () => handlePawnClick(pawnId));
            pawnEl.addEventListener('mouseenter', () => handlePawnHover(pawnId, true));
            pawnEl.addEventListener('mouseleave', () => handlePawnHover(pawnId, false));
            board.appendChild(pawnEl);
        }
    }
    
    function createDiceVisuals() {
        diceEl.innerHTML = '';
        const gridAreasFor6 = ["a . c", "f . g", "d . b"]; 
        for (let i = 1; i <= 6; i++) {
            const face = document.createElement('div');
            face.className = `dice-face face-${i}`;
            if (i === 6) {
                face.style.gridTemplateAreas = `"${gridAreasFor6[0]}" "${gridAreasFor6[1]}" "${gridAreasFor6[2]}"`;
            }
            for (let j = 0; j < i; j++) face.innerHTML += '<div class="dice-pip"></div>';
            diceEl.appendChild(face);
        }
    }

    function renderDice(value) { 
        const diceFacesTransforms = {
            1: 'rotateY(0deg) translateZ(40px)',
            2: 'rotateY(-90deg) translateZ(40px)',
            3: 'rotateY(90deg) translateZ(40px)',
            4: 'rotateX(-90deg) translateZ(40px)',
            5: 'rotateX(90deg) translateZ(40px)',
            6: 'rotateY(180deg) translateZ(40px)'
        };
        if (value >= 1 && value <= 6) {
            diceEl.style.transform = diceFacesTransforms[value];
        }
    }
    
    // --- Core Game Loop & Player Actions ---
    async function handleHumanRoll() {
        if (gameState.isAnimating || gameState.diceRolled) return;
        await rollDiceAndFindMoves(false);
    }

    async function handlePawnClick(pawnId) {
        const pawnEl = document.getElementById(pawnId);
        const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
        if (gameState.isAnimating || gameState.playerTypes[currentPlayer] === 'ai' || !pawnEl.classList.contains('movable')) return;
        
        clearHighlights();
        await executeMove(pawnId);
    }
    
    function handlePawnHover(pawnId, isEntering) {
        const pawnEl = document.getElementById(pawnId);
        if (!pawnEl || !pawnEl.classList.contains('movable')) return;
        
        const pawn = gameState.pawns[pawnId];
        const newPos = pawn.position === -1 ? 0 : pawn.position + gameState.diceValue;
        
        let targetCell;

        if (newPos >= TOTAL_LOGICAL_PATH_LENGTH) {
            // Can't highlight finish square if it means exact landing
        } else if (newPos >= MAIN_PATH_LOGICAL_LENGTH) {
            const finishIndex = newPos - MAIN_PATH_LOGICAL_LENGTH;
            if (finishIndex < FINISH_PATH_LENGTH) { 
                const [r, c] = PATH_DATA.FINISH_PATH_COORDS[pawn.color][finishIndex];
                targetCell = board.querySelector(`[data-row="${r}"][data-col="${c}"]`);
            }
        } else {
             const targetGlobalIndex = (newPos + PATH_DATA.START_POSITIONS[pawn.color]) % MAIN_PATH_LOGICAL_LENGTH;
             const [r, c] = PATH_DATA.PATH_COORDS[targetGlobalIndex];
             targetCell = board.querySelector(`[data-row="${r}"][data-col="${c}"]`);
        }

        if (targetCell) {
            if (isEntering) targetCell.classList.add('target-highlight');
            else targetCell.classList.remove('target-highlight');
        }
    }

    async function rollDiceAndFindMoves(isAI = false) {
        gameState.isAnimating = true; 
        diceEl.classList.remove('active');
        await rollDice(); 
        
        const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
        const movablePawns = findMovablePawns();

        if (movablePawns.length > 0) {
            if (!isAI) {
                movablePawns.forEach(pawnId => document.getElementById(pawnId).classList.add('movable'));
                updateStatus("Choose a pawn to move.");
                gameState.isAnimating = false; 
            }
            return movablePawns;
        } else {
            addToLog(`${currentPlayer.toUpperCase()} has no available moves.`);
            if (gameState.diceValue === 6) { 
                updateStatus("No moves, but you rolled a 6! Roll again.");
                gameState.diceRolled = false; 
                gameState.isAnimating = false; 
                if (!isAI) {
                    diceEl.classList.add('active');
                }
            } else { 
                updateStatus("No possible moves. Turn passes.");
                addToLog(`${currentPlayer.toUpperCase()}'s turn ends.`);
                gameState.isAnimating = false; 
                if(!isAI) {
                    passTurnBtn.style.display = 'block';
                } else {
                    await sleep(1000);
                    switchPlayer();
                }
            }
            return null; 
        }
    }


    async function executeMove(pawnId) {
        gameState.isAnimating = true;
        
        const pawn = gameState.pawns[pawnId];
        const originalPosition = pawn.position;

        await movePawnWithAnimation(pawn);
        
        await updateStacks(pawn, originalPosition);
        checkForCapture(pawn);
        await sleep(200); 

        checkForWin();
        if (gameState.gameWon) return;

        const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
        if (gameState.diceValue !== 6) {
            switchPlayer();
        } else { 
            gameState.diceRolled = false;
            gameState.isAnimating = false;
            addToLog(`${pawn.color.toUpperCase()} rolled a 6 and gets another turn.`);
            updateStatus("Rolled a 6! Roll again.");
            
            if (gameState.playerTypes[pawn.color] === 'human') {
                diceEl.classList.add('active');
            } else {
                setTimeout(executeAITurn, 500); 
            }
        }
    }
    
    async function rollDice() {
        gameState.diceRolled = true; 
        diceEl.classList.add('rolling');
        const randomX = Math.floor(Math.random() * 4) * 90;
        const randomY = Math.floor(Math.random() * 4) * 90;
        diceEl.style.transform = `rotateX(${randomX}deg) rotateY(${randomY}deg) translateZ(40px)`;

        await new Promise(resolve => setTimeout(resolve, parseFloat(getComputedStyle(root).getPropertyValue('--dice-roll-duration')) * 1000));

        diceEl.classList.remove('rolling');
        gameState.diceValue = Math.floor(Math.random() * 6) + 1;
        renderDice(gameState.diceValue); 
        updateStatus(); 
    }

    
    function findMovablePawns() {
        const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
        return Object.values(gameState.pawns).filter(pawn => {
            if (pawn.color !== currentPlayer || pawn.isFinished) return false;
            
            if (pawn.position === -1) return gameState.diceValue === 6;

            const targetPos = pawn.position + gameState.diceValue;
            if (targetPos >= TOTAL_LOGICAL_PATH_LENGTH) { 
                 return targetPos === TOTAL_LOGICAL_PATH_LENGTH; 
            }

            if (targetPos < MAIN_PATH_LOGICAL_LENGTH) {
                for (let i = pawn.position + 1; i < targetPos; i++) {
                    const stepGlobalIndex = getGlobalPathIndex({ ...pawn, position: i });
                    
                    const pawnsOnStep = Object.values(gameState.pawns).filter(p => 
                        p.position !== -1 && 
                        !p.isFinished && 
                        p.position < MAIN_PATH_LOGICAL_LENGTH && 
                        getGlobalPathIndex(p) === stepGlobalIndex
                    );

                    if (pawnsOnStep.length < 2) continue;

                    const pawnsByColorOnStep = pawnsOnStep.reduce((acc, p) => {
                        acc[p.color] = (acc[p.color] || 0) + 1;
                        return acc;
                    }, {});

                    for (const color in pawnsByColorOnStep) {
                        if(pawnsByColorOnStep[color] >= 2) return false; 
                    }
                }
            }
            return true;
        }).map(pawn => pawn.id);
    }

    async function movePawnWithAnimation(pawn, steps) {
        const pawnEl = document.getElementById(pawn.id);
        const startPos = pawn.position;
        const diceOrBoost = steps || gameState.diceValue;

        if (startPos === -1 && gameState.diceValue === 6) { 
            pawn.position = 0; 
            if (gameState.isSoundOn) hopSound.play();
            pawnEl.classList.add('hopping');
            const [top, left] = getPawnCoords(pawn);
            pawnEl.style.top = `${top}px`; pawnEl.style.left = `${left}px`;
            await sleep(300);
            pawnEl.classList.remove('hopping');
        } else {
            for (let i = 1; i <= diceOrBoost; i++) {
                const newPos = startPos + i;
                if (newPos > TOTAL_LOGICAL_PATH_LENGTH) break; 
                pawn.position = newPos;

                pawnEl.classList.add('hopping');
                if (gameState.isSoundOn) { hopSound.currentTime = 0; hopSound.play(); }
                const [top, left] = getPawnCoords(pawn);
                pawnEl.style.top = `${top}px`; pawnEl.style.left = `${left}px`;
                await sleep(pawn.position >= MAIN_PATH_LOGICAL_LENGTH ? (parseFloat(getComputedStyle(root).getPropertyValue('--hop-duration'))*1000 * 1.5) : (parseFloat(getComputedStyle(root).getPropertyValue('--hop-duration'))*1000));
                pawnEl.classList.remove('hopping');
                await sleep(parseFloat(getComputedStyle(root).getPropertyValue('--hop-interval'))*1000 / 5); 
            }
        }
        if (pawn.position === TOTAL_LOGICAL_PATH_LENGTH) {
            pawn.isFinished = true;
            addToLog(`${pawn.color.toUpperCase()}'s pawn reached home!`);
        }
    }

    async function updateStacks(movedPawn, previousPosition) {
        if (previousPosition !== -1) {
            const previousGlobalIndex = getGlobalPathIndex({ ...movedPawn, position: previousPosition });
            if (previousPosition < MAIN_PATH_LOGICAL_LENGTH || (previousPosition >= MAIN_PATH_LOGICAL_LENGTH && PATH_DATA.FINISH_PATH_COORDS[movedPawn.color].some(coord => {
                const [r,c] = getPawnCoords({...movedPawn, position: previousPosition}, true); // Get grid coords
                // Check if grid coords [r,c] are in this player's finish path
                 return PATH_DATA.FINISH_PATH_COORDS[movedPawn.color].find(fc => fc[0] === r && fc[1] === c);
            }))) {
                 const pawnsOnOldSquare = Object.values(gameState.pawns).filter(p => 
                    p.color === movedPawn.color && 
                    !p.isFinished && p.position !== -1 && 
                    // For main path, compare global indices
                    ( (p.position < MAIN_PATH_LOGICAL_LENGTH && previousPosition < MAIN_PATH_LOGICAL_LENGTH && getGlobalPathIndex(p) === previousGlobalIndex) ||
                    // For finish path, compare exact relative positions
                      (p.position >= MAIN_PATH_LOGICAL_LENGTH && previousPosition >= MAIN_PATH_LOGICAL_LENGTH && p.position === previousPosition) )
                );
                pawnsOnOldSquare.forEach(pawnToUpdate => updatePawnStackSize(pawnToUpdate.id, pawnsOnOldSquare.length));
            }
        }

        if (movedPawn.isFinished || movedPawn.position === -1) {
            updatePawnStackSize(movedPawn.id, 1); 
            return;
        }

        const currentGlobalIndex = getGlobalPathIndex(movedPawn);
        const pawnsOnNewSquare = Object.values(gameState.pawns).filter(p => 
            p.color === movedPawn.color && 
            !p.isFinished && p.position !== -1 &&
            ( (p.position < MAIN_PATH_LOGICAL_LENGTH && movedPawn.position < MAIN_PATH_LOGICAL_LENGTH && getGlobalPathIndex(p) === currentGlobalIndex) ||
              (p.position >= MAIN_PATH_LOGICAL_LENGTH && movedPawn.position >= MAIN_PATH_LOGICAL_LENGTH && p.position === movedPawn.position) )
        );
        const newStackSize = pawnsOnNewSquare.length;
        pawnsOnNewSquare.forEach(pawnToUpdate => updatePawnStackSize(pawnToUpdate.id, newStackSize));
        
        if (newStackSize > 1) {
            addToLog(`${movedPawn.color.toUpperCase()} formed a stack of ${newStackSize}.`);
        }
    }

    function updatePawnStackSize(pawnId, size) {
        const pawn = gameState.pawns[pawnId];
        if (!pawn) return;
        pawn.stackSize = size;
        const pawnEl = document.getElementById(pawnId);
        if (!pawnEl) return;
        
        if (size > 1) {
            pawnEl.dataset.stackSize = `x${size}`;
        } else {
            delete pawnEl.dataset.stackSize;
        }
    }

    function checkForCapture(movedPawn) {
        if (movedPawn.isFinished || movedPawn.position < 0 || movedPawn.position >= MAIN_PATH_LOGICAL_LENGTH) return; 
        
        const movedGlobalIndex = getGlobalPathIndex(movedPawn);
        const isStartSquare = Object.values(PATH_DATA.START_POSITIONS).includes(movedGlobalIndex);
        if (isStartSquare) return; 

        const opponentsOnSquare = Object.values(gameState.pawns).filter(otherPawn => 
            otherPawn.color !== movedPawn.color && 
            !otherPawn.isFinished && 
            otherPawn.position !== -1 &&
            otherPawn.position < MAIN_PATH_LOGICAL_LENGTH && 
            getGlobalPathIndex(otherPawn) === movedGlobalIndex);
            
        if (opponentsOnSquare.length > 0) {
            const opponentStackSize = opponentsOnSquare[0].stackSize; 
            if (movedPawn.stackSize >= opponentStackSize) {
                addToLog(`${movedPawn.color.toUpperCase()} captured ${opponentsOnSquare[0].color.toUpperCase()}'s stack!`);
                opponentsOnSquare.forEach(capturedPawn => {
                    capturedPawn.position = -1; 
                    updatePawnStackSize(capturedPawn.id, 1); 
                    const capturedPawnEl = document.getElementById(capturedPawn.id);
                    const [top, left] = getPawnCoords(capturedPawn);
                    capturedPawnEl.classList.add('hopping');
                    capturedPawnEl.style.top = `${top}px`; 
                    capturedPawnEl.style.left = `${left}px`;
                    setTimeout(() => capturedPawnEl.classList.remove('hopping'), parseFloat(getComputedStyle(root).getPropertyValue('--hop-duration')) * 1000);
                });
            } else {
                addToLog(`${movedPawn.color.toUpperCase()} could not capture ${opponentsOnSquare[0].color.toUpperCase()}'s larger stack.`);
            }
        }
    }
    
    function checkForWin() {
        const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
        const allFinished = Object.values(gameState.pawns)
                                .filter(p => p.color === currentPlayer)
                                .every(p => p.isFinished);
        if (allFinished && !gameState.winners.includes(currentPlayer)) {
            gameState.winners.push(currentPlayer);
            const place = ["1st", "2nd", "3rd"][gameState.winners.length - 1] || `${gameState.winners.length}th`;
            addToLog(`${currentPlayer.toUpperCase()} finished in ${place} place!`);
            
            if (gameState.numPlayers > 1 && gameState.winners.length >= gameState.numPlayers - 1) {
                gameState.gameWon = true;
                const lastPlayer = gameState.activePlayers.find(p => !gameState.winners.includes(p));
                if (lastPlayer && !gameState.winners.includes(lastPlayer)) gameState.winners.push(lastPlayer);
                showWinnerPodium();
            } else if (gameState.numPlayers === 1 && gameState.winners.length === 1) { 
                gameState.gameWon = true;
                showWinnerPodium();
            }
        }
    }
    
    // --- Game State & UI Management ---
    function switchPlayer() {
        clearHighlights();
        passTurnBtn.style.display = 'none';
        
        gameState.isAnimating = false; 
        gameState.diceRolled = false;
        gameState.diceValue = null;

        let nextPlayerFound = false;
        for(let i=0; i < gameState.activePlayers.length; i++) {
            gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.activePlayers.length;
            const nextPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
            if (!gameState.winners.includes(nextPlayer)) {
                nextPlayerFound = true;
                break;
            }
        }

        if(!nextPlayerFound || gameState.gameWon) {
            return;
        }

        const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
        updateTurnIndicator();
        updateStatus(); 

        if (gameState.playerTypes[currentPlayer] === 'ai' && !gameState.gameWon) {
            diceEl.style.pointerEvents = 'none';
            gameState.isAnimating = true; 
            setTimeout(executeAITurn, 1000);
        } else if (!gameState.gameWon) {
            diceEl.style.pointerEvents = 'auto';
            diceEl.classList.add("active");
            gameState.isAnimating = false; 
        }
    }

    function updateStatus(message = "") {
        if (!gameState.activePlayers || gameState.activePlayers.length === 0 || gameState.currentPlayerIndex === -1) {
             statusEl.innerHTML = message || "Initializing..."; // Or some default
             return;
        }
        const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
        if (!currentPlayer) return;

        const playerInfo = PLAYERS[currentPlayer];
        const playerType = gameState.playerTypes[currentPlayer];

        if (message) {
             statusEl.innerHTML = message;
        } else {
            let turnText = gameState.diceValue 
                ? `<strong style="color:${playerInfo.color}">${currentPlayer.toUpperCase()}</strong> rolled a ${gameState.diceValue}. `
                : `It's <strong style="color:${playerInfo.color}">${currentPlayer.toUpperCase()}</strong>'s turn. `;
            
            turnText += playerType === 'ai' 
                ? `(AI) is thinking...`
                : `Roll the dice!`;
            statusEl.innerHTML = turnText;
        }
        
        root.style.setProperty("--current-player-color", playerInfo.color);
        root.style.setProperty("--current-player-color-glow", playerInfo.glow);
    }
    
    function updateTurnIndicator() {
        if (!board.clientWidth) return; // Don't update if board not sized
        const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
        if (!currentPlayer) return;

        const cellSize = board.clientWidth / 15;
        const positions = {
            red: { top: 0, left: 0, width: cellSize * 6, height: cellSize * 6 },
            green: { top: 0, left: cellSize * 9, width: cellSize * 6, height: cellSize * 6 },
            yellow: { top: cellSize * 9, left: cellSize * 9, width: cellSize * 6, height: cellSize * 6 },
            blue: { top: cellSize * 9, left: 0, width: cellSize * 6, height: cellSize * 6 },
        };
        const pos = positions[currentPlayer];
        turnIndicator.style.top = `${pos.top}px`;
        turnIndicator.style.left = `${pos.left}px`;
        turnIndicator.style.width = `${pos.width}px`;
        turnIndicator.style.height = `${pos.height}px`;
    }

    function addToLog(message) {
        gameState.gameLog.push(message);
        if (gameState.gameLog.length > 20) gameState.gameLog.shift();
        
        gameLogEl.innerHTML = gameState.gameLog.map(msg => `<p>${msg}</p>`).join('');
        gameLogEl.scrollTop = gameLogEl.scrollHeight;
    }

    function clearHighlights() {
        document.querySelectorAll('.movable').forEach(el => el.classList.remove('movable'));
        document.querySelectorAll('.target-highlight').forEach(el => el.classList.remove('target-highlight'));
    }

    function toggleSound() {
        gameState.isSoundOn = !gameState.isSoundOn;
        soundBtn.textContent = gameState.isSoundOn ? '🔊' : '🔇';
        hopSound.volume = gameState.isSoundOn ? 0.4 : 0;
    }
    
    function showWinnerPodium() {
        winnerPodiumEl.innerHTML = '';
        gameState.winners.slice(0, 3).forEach((color, index) => {
            winnerPodiumEl.innerHTML += `
                <div class="podium-stand podium-${index + 1}">
                    <div class="pawn ${color}"></div>
                    <span>${color.toUpperCase()}</span>
                </div>`;
        });
        winnerModal.style.display = 'flex';
    }

    // --- AI Logic ---
    async function executeAITurn() {
        if (gameState.gameWon || !gameState.activePlayers[gameState.currentPlayerIndex] || gameState.playerTypes[gameState.activePlayers[gameState.currentPlayerIndex]] !== 'ai') {
            gameState.isAnimating = false; 
            return;
        }
        
        gameState.isAnimating = true; 
        const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
        updateStatus(`${currentPlayer.toUpperCase()} (AI) is thinking...`);
        await sleep(800);

        if (!gameState.diceRolled) {
            const movablePawns = await rollDiceAndFindMoves(true); 

            if (movablePawns && movablePawns.length > 0) {
                await sleep(500);
                const bestPawnId = aiChooseBestMove(movablePawns);
                await executeMove(bestPawnId); 
            } else {
                 if (!gameState.diceRolled && gameState.diceValue === 6) { 
                    setTimeout(executeAITurn, 500);
                 } else if (gameState.diceRolled) { 
                    gameState.isAnimating = false; 
                 }
            }
        } else {
            console.warn("AI turn with dice already rolled. Attempting to find moves.");
            const movablePawns = findMovablePawns();
            if (movablePawns && movablePawns.length > 0) {
                const bestPawnId = aiChooseBestMove(movablePawns);
                await executeMove(bestPawnId);
            } else {
                if (gameState.diceValue === 6) {
                    gameState.diceRolled = false;
                    setTimeout(executeAITurn, 500);
                } else {
                    switchPlayer(); 
                }
            }
        }
    }
    
    function aiChooseBestMove(movablePawns) {
        let bestMove = { pawnId: null, score: -Infinity };
        const currentPlayer = gameState.activePlayers[gameState.currentPlayerIndex];
        const dice = gameState.diceValue;

        for(const pawnId of movablePawns) {
            const pawn = gameState.pawns[pawnId];
            let score = 0;
            
            const newPos = (pawn.position === -1) ? 0 : pawn.position + dice; 
            if (newPos > TOTAL_LOGICAL_PATH_LENGTH) continue; 

            score += dice; 

            if (newPos === TOTAL_LOGICAL_PATH_LENGTH) score += 1000;
            
            if (pawn.position === -1 && dice === 6) score += 50;
            
            if (pawn.position !== -1) score += newPos * 2; 

            if (newPos < MAIN_PATH_LOGICAL_LENGTH) { 
                const newGlobalIndex = (newPos + PATH_DATA.START_POSITIONS[pawn.color]) % MAIN_PATH_LOGICAL_LENGTH;
                
                if (newGlobalIndex === PATH_DATA.START_POSITIONS[pawn.color]) score += 30;
                else if (Object.values(PATH_DATA.START_POSITIONS).includes(newGlobalIndex)) score += 10;

                const opponentsOnSquare = Object.values(gameState.pawns).filter(op => 
                    op.color !== pawn.color && 
                    op.position !== -1 && !op.isFinished && op.position < MAIN_PATH_LOGICAL_LENGTH &&
                    getGlobalPathIndex(op) === newGlobalIndex);
                if (opponentsOnSquare.length > 0) {
                    const opponentStackSize = opponentsOnSquare[0].stackSize;
                    if (pawn.stackSize >= opponentStackSize && !Object.values(PATH_DATA.START_POSITIONS).includes(newGlobalIndex)) {
                         score += 75 * opponentStackSize; 
                    }
                }
                
                const alliesOnSquareAfterMove = Object.values(gameState.pawns).filter(ally => 
                    ally.id !== pawn.id && 
                    ally.color === pawn.color && 
                    !ally.isFinished && ally.position !== -1 && ally.position < MAIN_PATH_LOGICAL_LENGTH &&
                    getGlobalPathIndex(ally) === newGlobalIndex
                ).length + 1; 

                if (alliesOnSquareAfterMove > 1 && !Object.values(PATH_DATA.START_POSITIONS).includes(newGlobalIndex)) {
                    score += 60; 
                    if (alliesOnSquareAfterMove > pawn.stackSize && pawn.stackSize === 1) score += 10; 
                }

                let dangerScore = 0;
                for (const otherPlayerColor of gameState.activePlayers) {
                    if (otherPlayerColor === pawn.color || gameState.winners.includes(otherPlayerColor)) continue;
                    Object.values(gameState.pawns).filter(op => op.color === otherPlayerColor && op.position !== -1 && !op.isFinished).forEach(opponentPawn => {
                        for (let d = 1; d <= 6; d++) {
                            const opponentPotentialTargetPos = (opponentPawn.position + d + PATH_DATA.START_POSITIONS[opponentPawn.color]) % MAIN_PATH_LOGICAL_LENGTH;
                            if (opponentPotentialTargetPos === newGlobalIndex) {
                                dangerScore -= 30; 
                                if (opponentPawn.stackSize >= alliesOnSquareAfterMove) dangerScore -= 20; 
                                break; 
                            }
                        }
                    });
                }
                score += dangerScore;
            } else if (newPos < TOTAL_LOGICAL_PATH_LENGTH) { 
                score += 20; 
            }

            if(score > bestMove.score) {
                bestMove = { pawnId, score };
            }
        }
        return bestMove.pawnId || movablePawns[0]; 
    }
    
    // --- Utility Functions ---
    const getGlobalPathIndex = (pawn) => {
        if (pawn.position === -1 || pawn.position >= MAIN_PATH_LOGICAL_LENGTH) return -1; 
        return (pawn.position + PATH_DATA.START_POSITIONS[pawn.color]) % MAIN_PATH_LOGICAL_LENGTH;
    };

    function getPawnCoords(pawn, returnGrid = false) {
        const { id, color, position, isFinished } = pawn;
        const cellSize = board.clientWidth / 15;
        // If cellSize is 0, it means board is not yet sized properly.
        // Return default or throw error, or handle gracefully. For now, it might lead to NaNs or 0s.
        if (cellSize === 0) {
            // console.warn("getPawnCoords called with cellSize 0 for pawn:", pawn.id);
            return returnGrid ? [0,0] : [0,0]; // Fallback if board not sized
        }
        const pawnSizeVal = parseFloat(getComputedStyle(root).getPropertyValue('--pawn-size')); // Actual pawn size in px
        const centerOffset = (cellSize - pawnSizeVal) / 2;


        let row, col;

        if (position === -1) { 
            const homeIndex = parseInt(id.slice(-1)); 
            [row, col] = PATH_DATA.HOME_SPOTS[color][homeIndex];
        } else if (isFinished || position === TOTAL_LOGICAL_PATH_LENGTH) { 
            [row, col] = [7, 7]; 
        } else if (position >= MAIN_PATH_LOGICAL_LENGTH) { 
            const finishIndex = position - MAIN_PATH_LOGICAL_LENGTH;
            if (finishIndex < PATH_DATA.FINISH_PATH_COORDS[color].length) {
                [row, col] = PATH_DATA.FINISH_PATH_COORDS[color][finishIndex];
            } else { 
                [row, col] = [7, 7]; 
            }
        } else { 
            const pathIndex = (position + PATH_DATA.START_POSITIONS[color]) % MAIN_PATH_LOGICAL_LENGTH;
            [row, col] = PATH_DATA.PATH_COORDS[pathIndex];
        }

        if (returnGrid) return [row, col];
        return [row * cellSize + centerOffset, col * cellSize + centerOffset];
    }

    // --- Initializer ---
    setupMenu();
});
</script>
</body>
</html>
